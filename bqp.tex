\section{Delegation for BQP}
\label{sec:BlindBQP}

\Ethan{Read other papers and see if I can copy their tones and phrasing}

\Ethan{Important lemmas such as 2.4 should be emphasized more and especially this one shouldn't be in prelim.}

\Ethan{2.4 should be a key obsv.}

\Ethan{If the original is wordy, just keep it the way it is. Don't try to simplify existing dfns.}

\Ethan{Two main problems; 1. not professional enough, 2. flow}

In this section we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

We start with a high-level description of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which was in turn taken from \cite{mf16}.

\Ethan{below is copied and pasted from google docs and might need a bit of rephrasing}
Thm 8.4 in Urmila's paper gives a one-message $\QPIP_1$ protocol with XZ measurement for deciding BQP language L.
Roughly, on input $x \in\set{0,1}^n$,  P will send a m = poly(n) qubit certificate state $\rho$ to V qubit by qubit.
V will sample a measurement setting $h \in \set{0,1}^m$ according to certain distribution $\pi_x$, and use h to determine how to measure $\rho$.
Specifically, if $h_i = 0$ (resp., 1), then V will measure the i-th qubit using  X (resp., Z) measurement, and verify the measurement outcome.

\begin{protocol}{Verifying yes-instances for $\BQP$}
	\label{proto:BQP}
	Let $L\in\BQP$, and $x\in\set{0,1}^n$. Let $m=\poly(n)$
	\begin{enumerate}
		\item On input $L$ and $x$, the verifier samples $\Lambda$ from a certain distribution $\pi_{L, x}$, where $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$; each $\Lambda_i$ is single-qubit $X$ or $Z$ measurements.
		\item The verifier sends $x$ to the prover.
		\item The prover applies a certain CPTP $\cF$ on $x$ to generate $\rho\in\cB^{\otimes m}$.
			\Ethan{Now we need to define CPTP in prelim...}
		\item The prover sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming qubits of $\rho$ according to $\Lambda$ to get $c$.
		\item The verifier runs some $\BPP$ algorithm $\cV$ on input $c$ and outputs either accept or reject.
	\end{enumerate}
\end{protocol}

\Ethan{below is copied from google docs and need rephrasing}

compile this protocol using QFHE to obtain a blind one message $\QPIP_1$ protocol for BQP with XZ measurement.
High level idea:  run the protocol under Urmila’s QFHE. Namely, $\tilde{V}$ sends $ct = Enc(x)$ to $\tilde{P}$, then $\tilde{P}$ homomorphically evaluate $P_1$ on ct to produce $\tilde{rho} = Enc(\rho)$ and send the encrypted certificate state to $\tilde{V}$.
Discussion: Now $\tilde{V}$ need to obtain the measurement outcome w from the encrypted state $\tilde{rho}$ using qubit-by-qubit XZ measurements. This may not be possible in general. 
Key observation: Our key observation is that Urmila’s QFHE scheme allows this. 
Explain why: Urmila’s QFHE ciphertext has the form of  QOTP on quantum msg + classical FHE ciphertext. So $\tilde{V}$ can do blah blah XZ measurement on $\tilde{rho}$, and recover w from the measurement outcome. We state this as the following fact/key observation: ...


\begin{thm}
	\label{decodeMeasureOrder}
	Let $sk$ be some secret key of $\mathsf{QHE}$.
	Let $n\in\bbN$.
	Let $m\in\bbN$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.
	Let $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$, where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.

	There exists $\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$ where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and $\BPP$ algorithm $\widehat{\mathsf{QHE.Dec}}$ such that:
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{proof}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$

	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $ct=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $ct$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $ct$ to get $\Lambda(\rho)$.
\end{proof}

\cref{proto:BQP} has negligible completeness and soundness.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\begin{protocol}{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	\Ethan{Define/quantify $x$ and whatnot}
	Let $d$ be the depth of the circuit corresponding to $\cF$.
	Take $\pi_{L, x}$, $\cF$, and $\cV$ to be the same as in \cref{proto:BQP}
	\begin{enumerate}
		\item The verifier samples $\Lambda$ from $\pi_{L, x}$
		\item The verifier computes $\Lambda'$ using \cref{decodeMeasureOrder}
		\item The verifier runs $\mathsf{QHE.Keygen}(1^n, 1^d)$ to get $pk, sk, evk$.
		\item The verifier computes $c=\mathsf{QHE.Enc}_{pk}(x)$
		\item The verifier sends $c$ and $evk$ to the prover
		\item The prover computes $\sigma=\mathsf{QHE.Eval}(\cF, c)$
		\item The prover sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext according to $\Lambda'$, getting $ct$
		\item The verifier applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to $ct$, getting $c$.
		\item The verifier applies $\cV$ to $c$ and outputs its result.
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and IND-CPA protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\cref{proto:BlindBQP} has negligible completeness and soundness.
\end{thm}
\begin{proof}
    \Ethan{Completeness is trivial, but soundness isn't as trivial as this makes it look like}
	Based on the correctness of $\mathsf{QHE}$, any prover strategy in \cref{proto:BlindBQP} has a corresponding strategy in \cref{proto:BQP}.
\end{proof}

\begin{thm}
	\cref{proto:BlindBQP} is blind.
\end{thm}
\begin{proof}
	The only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.
\end{proof}

\cite{mahadev_delegation} gives a compiler from $\QPIP_1$ protocols of the form in \cref{proto:BQP} to $\QPIP_0$ but deteriorates soundness.
Note that \cref{proto:BlindBQP} can also be collapsed into the same form, so the same compiler can also be applied to it to obtain a $\QPIP_0$ protocol.

We can then use results from \cite{parallelrep} to apply parallel repetition and recover the negligible soundness.

Our results for $\BQP$ can also be generalized to $\FBQP$ by applying $2n$ copies of \cref{thm:QPIP0BQP} in parallel.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{QPIP0FBQP}
	Suppose $y\in\set{0,1}^m$ is the output of our $\FBQP$ instance.
	\begin{enumerate}
		\item Apply \cref{thm:QPIP0BQP} to every $y_i=0$ and $y_i=1$ case in parallel, resulting in a total of $2m$ cases.
		\item Output $y$ if for each $i$ precisely one of the $y_i=0$ and $y=i=1$ cases accepts.
	\end{enumerate}
\end{protocol}

\Ethan{TODO prove that \cref{QPIP0FBQP} actually works as expected}
