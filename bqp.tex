\section{Delegation for BQP}
\label{sec:BlindBQP}

In this section we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

Let $L\in\BQP$, and $x\in\set{0,1}^n$.
We start with an overview of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which was in turn taken from \cite{mf16}.

\begin{protocol}{Verifying yes-instances for $\BQP$}
	\label{proto:BQP}
	We give only a high-level description here.
	For more details, see \cref{AlgGroundStateCheck} where we generalize this for $\SampBQP$.
	\begin{enumerate}
		\item The verifier chooses some tensor product of $X$ and $Z$ measurements $\Lambda$
		\item The prover sends the verifier some state $\rho\in\cB^{\otimes m}$ qubit-by-qubit.
		\item The verifier measures $\rho$ according to $S$
		\item The verifier decides whether to accept based on the measurement results.
	\end{enumerate}
\end{protocol}

Differently from \cref{AlgGroundStateCheck}, \cref{proto:BQP} has negligible completeness and soundness, due to parallel repetition.
We denote the honest prover's action in \cref{proto:BQP} as $\cF$.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\begin{protocol}{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	Let $d$ be the depth of the circuit corresponding to $\cF$.
	\begin{enumerate}
		\item The verifier chooses $\Lambda$ and computes $\Lambda'$ using \cref{decodeMeasureOrder}
		\item The verifier runs $\mathsf{QHE.Keygen}(1^n, 1^d)$ to get $pk, sk, evk$.
		\item The verifier computes $c=\mathsf{QHE.Enc}_{pk}(x)$
		\item The verifier sends $c$ and $evk$ to the prover
		\item The prover computes $\mathsf{QHE.Eval}(\cF, c)$ and sends it to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext according to $\Lambda'$
		\item The verifier applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to the measurement results
		\item The verifier decides whether to accept based on \cref{proto:BQP}
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and IND-CPA protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\cref{proto:BlindBQP} preserves the completeness and soundness of \cref{proto:BQP}
\end{thm}
\begin{proof}
	Based on the correctness of $\mathsf{QHE}$, any prover strategy in \cref{proto:BlindBQP} has a corresponding strategy in \cref{proto:BQP}.
\end{proof}

\begin{thm}
	\cref{proto:BlindBQP} is IND-CPA secure.
\end{thm}
\begin{proof}
	The only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.
\end{proof}

\cite{mahadev_delegation} gives a compiler from $\QPIP_1$ protocols of the form in \cref{proto:BQP} to $\QPIP_0$ but deteriorates soundness.
Note that \cref{proto:BlindBQP} can also be collapsed into the same form, so the same compiler can also be applied to it to obtain a $\QPIP_0$ protocol.

We can then use results from \cite{parallelrep} to apply parallel repetition and recover the negligible soundness.

Our results for $\BQP$ can also be generalized to $\FBQP$ by applying $2n$ copies of \cref{thm:QPIP0BQP} in parallel.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{QPIP0FBQP}
	Suppose $y\in\set{0,1}^m$ is the output of our $\FBQP$ instance.
	\begin{enumerate}
		\item Apply \cref{thm:QPIP0BQP} to every $y_i=0$ and $y_i=1$ case in parallel, resulting in a total of $2m$ cases.
		\item Output $y$ if for each $i$ precisely one of the $y_i=0$ and $y=i=1$ cases accepts.
	\end{enumerate}
\end{protocol}

\Ethan{TODO prove that \cref{QPIP0FBQP} actually works as expected}
