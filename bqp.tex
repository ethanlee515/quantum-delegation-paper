\section{Delegation for BQP}
\label{sec:BlindBQP}

\Ethan{More feedback notes go here to be implemented later}

\Ethan{Read other papers and see if I can copy their tones and phrasing}

\Ethan{Important lemmas such as 2.4 should be emphasized more and especially this one shouldn't be in prelim.}

\Ethan{2.4 should be a key obsv.}

\Ethan{protocol 2 should say 1 message QPIP1 for BQP}

\Ethan{``choose some tensor"? need distribution info and some basis choice}

\Ethan{Try copying from https://arxiv.org/pdf/1911.08101.pdf pg 11?}

\Ethan{Or parallel rep with efficient ver.}

\Ethan{If the original is wordy, just keep it the way it is. Don't try to simplify existing dfns.}

\Ethan{Two main problems; 1. not professional enough, 2. flow}

\Ethan{Just syntax of QFHE in the preliminary; move the theorem here}

\Ethan{end of notes}

In this section we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

\Ethan{Take out the following and take from google docs}

Let $L\in\BQP$, and $x\in\set{0,1}^n$.
We start with an overview of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which was in turn taken from \cite{mf16}.

\begin{protocol}{Verifying yes-instances for $\BQP$}
	\label{proto:BQP}
	We give only a high-level description here.
	\Ethan{Don't say this}
	For more details, see \cref{AlgGroundStateCheck} where we generalize this for $\SampBQP$.
	\Ethan{Reference something else; referencing $\SampBQP$ is a bad idea here}
	    \Ethan{Phrase like ``for some input x, generate y"}
	\begin{enumerate}
		\item The verifier chooses some tensor product of $X$ and $Z$ measurements $\Lambda$
		\Ethan{just say there's some certain distribution that $\Lambda$ was sampled from}
		\item The prover sends the verifier some state $\rho\in\cB^{\otimes m}$ qubit-by-qubit. \Ethan{quantify m?}
		\item The verifier measures $\rho$ according to $S$ \Ethan{give measurement outcome notation}
		\item The verifier decides whether to accept based on the measurement results. \Ethan{``Takes measurement outcome and generates acc/rej"}
	\end{enumerate}
\end{protocol}

Differently from \cref{AlgGroundStateCheck}, \cref{proto:BQP} has negligible completeness and soundness, due to parallel repetition.
We denote the honest prover's action in \cref{proto:BQP} as $\cF$.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\begin{protocol}{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	\Ethan{Define/quantify $x$ and whatnot}
	Let $d$ be the depth of the circuit corresponding to $\cF$.
	\begin{enumerate}
		\item The verifier chooses $\Lambda$ and computes $\Lambda'$ using \cref{decodeMeasureOrder}
		\Ethan{Reference to particular steps of the last protocol}
		\item The verifier runs $\mathsf{QHE.Keygen}(1^n, 1^d)$ to get $pk, sk, evk$.
		\item The verifier computes $c=\mathsf{QHE.Enc}_{pk}(x)$
		\item The verifier sends $c$ and $evk$ to the prover
		\item The prover computes $\mathsf{QHE.Eval}(\cF, c)$ and sends it to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext according to $\Lambda'$
		\item The verifier applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to the measurement results
		\item The verifier decides whether to accept based on \cref{proto:BQP}
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and IND-CPA protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\cref{proto:BlindBQP} preserves the completeness and soundness of \cref{proto:BQP}
\end{thm}
\begin{proof}
    \Ethan{Completeness is trivial, but soundness isn't as trivial as this makes it look like}
	Based on the correctness of $\mathsf{QHE}$, any prover strategy in \cref{proto:BlindBQP} has a corresponding strategy in \cref{proto:BQP}.
\end{proof}

\begin{thm}
    \Ethan{Use ``blind", not IND-CPA for protocols}
	\cref{proto:BlindBQP} is IND-CPA secure.
\end{thm}
\begin{proof}
	The only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.
\end{proof}

\cite{mahadev_delegation} gives a compiler from $\QPIP_1$ protocols of the form in \cref{proto:BQP} to $\QPIP_0$ but deteriorates soundness.
Note that \cref{proto:BlindBQP} can also be collapsed into the same form, so the same compiler can also be applied to it to obtain a $\QPIP_0$ protocol.

We can then use results from \cite{parallelrep} to apply parallel repetition and recover the negligible soundness.

Our results for $\BQP$ can also be generalized to $\FBQP$ by applying $2n$ copies of \cref{thm:QPIP0BQP} in parallel.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{QPIP0FBQP}
	Suppose $y\in\set{0,1}^m$ is the output of our $\FBQP$ instance.
	\begin{enumerate}
		\item Apply \cref{thm:QPIP0BQP} to every $y_i=0$ and $y_i=1$ case in parallel, resulting in a total of $2m$ cases.
		\item Output $y$ if for each $i$ precisely one of the $y_i=0$ and $y=i=1$ cases accepts.
	\end{enumerate}
\end{protocol}

\Ethan{TODO prove that \cref{QPIP0FBQP} actually works as expected}
