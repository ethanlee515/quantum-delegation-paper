\section{Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP}

\Ethan{TODO Read other papers and see if I can copy their tones and phrasing}

\Ethan{Note to self: If the original is wordy, just keep it the way it is. Don't try to simplify existing dfns.}

\Ethan{TODO Intro this section}

\Ethan{See https://www.iis.sinica.edu.tw/~kmchung/download/ConstCZK.pdf for conventions. Mal. parties have stars, protos use Pi. Stuff like $r(P(w), V )(1n ,(M, x, t))$ }

\Ethan{More notation, fix interfaces}

\Ethan{Fix up to proto 3 and proofs}

\subsection{Blind Delegation for BQP}
\label{subsec:BlindBQP}

In this subsection we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

We start with a high-level description of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which is in turn taken from \cite{mf16}.

This is a one-message $\QPIP_1$ protocol with only $X$ and $Z$ measurement for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a $m$-qubit certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a product measurement $\Lambda$ of $X$ and $Z$s according to certain distribution to apply to $\rho$
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol $\Pi_{MF} = (P_{MF}, V_{MF})$ for $\BQP$ language $L$ \Ethan{TODO use macros}}
	\label{proto:BQP}
	Common input: $x\in\set{0,1}^n$. 
	\begin{enumerate}
		\item The verifier generates $\Lambda \leftarrow \cV_1(x)$, where $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$; each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement and $m=\poly(n)$ is the length of the prover's certificate state.
		\Ethan{change $\cV_1$ to $\cV_{MF, 1}$}
		\item The prover generates a certificate state $\rho\leftarrow\cP_2(x)$  and sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier applies the measurement $\Lambda$ to $\rho$ qubit-by-qubit. Let $w \in \set{0,1}^n$ denote the measurement outcome. It verifies the measurement outcome and produces a decision  $o\leftarrow\cV_3(x, \Lambda, w)$ where $o\in\set{acc, rej}$ and $\cV_3$ is a classical polynomial-time algorithm.
	\end{enumerate}
\end{protocol}

We compile this protocol using Mahadev's $\mathsf{QHE}$ from \cite{mahadev_qfhe} to obtain a blind 1-message $\QPIP_1$ protocol for $\BQP$, again with only $X$ and $Z$ measurements.
The high level idea is to run \cref{proto:BQP} under $\mathsf{QHE}$.
Namely, the verifier encrypts its original input $x$ and sends $y=\mathsf{QHE.Enc}(x)$ to the prover.
The prover then homomorphically evaluate $\cF$ on $y$ to produce $\sigma=\mathsf{QHE.Enc}(\rho)$ \Ethan{Is this actually ok? $\sigma$ is a ciphertext corresponding to $\rho$, but it wasn't encrypted. In fact it's deteriorated due to homomorphic eval} and send it back to the verifier.

Now the verifier needs to obtain the measurement outcome $w$ from the encrypted state $\sigma$ using qubit-by-qubit $X$ and $Z$ measurements.
This may not be possible in general, but we observe that $\mathsf{QHE}$ allows this. 
Its ciphertexts consists of a Pauli one-time-padded plaintext and classically encrypted Pauli keys.
Pauli one-time-pads commute with $X$ and $Z$ measurements, so the verifier can measure the one-time-padded state as usual then correct the measurement results using the Pauli keys.
We state this observation as the following theorem:

\begin{thm}
	\label{decodeMeasureOrder}
	Let $sk$ be some secret key of $\mathsf{QHE}$.
	Let $n\in\bbN$.
	Let $m\in\bbN$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.
	Let $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$, where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.

	There exists $\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$ where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and polynomial-time algorithm $\widehat{\mathsf{QHE.Dec}}$ such that:
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{prf}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$

	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $u=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $u$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $u$ to get $\Lambda(\rho)$.
\end{prf}

\cref{proto:BQP} has negligible completeness and soundness.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\Ethan{TODO PROOFREAD ME}

\begin{protocol}{Blind Protocol $\Pi_{blind} = (P_{blind}, V_{blind}$) for $\BQP$ \Ethan{Define and use macros later}}
	\label{proto:BlindBQP}
	Let $x\in\set{0,1}^n$.
	Let $d=\poly(n)$ be the depth of the circuit corresponding to $\cF$.
	\begin{enumerate}
		\item The verifier, on input $x$ generates $\Lambda$ using $\cV_1$ of \cref{proto:BQP}.
			On input $\Lambda$, it computes $\Lambda'$ using \cref{decodeMeasureOrder}.
			It computes $(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$, and $y\leftarrow\mathsf{QHE.Enc}_{pk}(x)$.
			Finally, it sends $y$ and $evk$ to the prover
		\item The prover homomorphically evaluates $\cP_2$ of \cref{proto:BQP} on input $y$, generating $\sigma=\mathsf{QHE.Eval}(\cP_2, y)$.
			The prover sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext $\sigma$ according to $\Lambda'$, getting $ct$
			It applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to $ct$, getting $w$.
			On input $w$, it applies $\cV_3$ of \cref{proto:BQP} and outputs its result.
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and blind protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\cref{proto:BlindBQP} has negligible completeness and soundness, and is blind.
\end{thm}
\begin{prf}
	The completeness follows by inspection.
	For blindness, the only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.

	\Ethan{TODO PROOFREAD ME}
	\Ethan{Convention: malicious parties have stars}
	
	\Ethan{Don't use blackboard bold for provers/verifiers}
	
	Suppose for the sake of contradiction that some prover $\bbP_{blind}^*$ breaks the soundness of \cref{proto:BlindBQP}.

	Then we use it to construct a prover $\bbP_{MF}^*$ against the soundness guarantees in \cref{proto:BQP}.

	$\bbP_{MF}^*$ simulates \cref{proto:BlindBQP} as $(V_{blind}(x), P_{blind}^*)()$
	
	\Ethan{Fix interface; $P_{blind}^*$ expects some message from $V$}

	When $\bbP_{blind}^*$ sends $\sigma$, $\bbP_{MF}^*$ computes and sends $\rho=\mathsf{QHE.Dec}_{sk}(\sigma)$ to the verifier. \Ethan{Make observation that $P_{blind}^*$ has $sk$}

	By assumption, $\bbV_{Blind}$ has a non-negligible chance to accept after receiving $\sigma$.
	When that happens, $\cV(w)=\cV(\Lambda(\rho))=Acc$.
	So $\bbV_{MF}$ has the same probability to accept after receiving $\rho$.
\end{prf}

\Ethan{TODO Below is copied from google docs; fix phrasing later}

Finally, we prove Thm 3.1 by applying Mahadev's measurement protocol~\cite{mahadev_delegation} to Protocol 3 to compile it into a $\QPIP_0$ protocol $(P', V')$ \Ethan{fix name}.
Note that Mahadev's measurement protocol can compile any $\QPIP_1$ protocol with X, Z measurement and negligible soundness to a $\QPIP_0$ protocol, and Protocol 3 is a $\QPIP_1$ protocol with X, Z measurement and negligible soundness.
Thus the resulting protocol $(P', V')$ is a O(1)-round $\QPIP_0$ protocol with soundness error $\frac{3}{4} + \negl(n)$

\Ethan{TODO PROOFREAD ME}
We give a high-level overview of the compiliation results.

\begin{protocol}{\Cref{proto:BlindBQP} compiled using Mahadev's measurement protocol}
	\label{proto:QPIP0BQP}
	\begin{enumerate}
		\item The verifier generates $\Lambda, \Lambda', pk, sk, evk, y$ the same way as in \cref{proto:BlindBQP}.
			On input $\Lambda'$, it generates $k, td$.
			It sends $k, evk, y$ to the prover.
		\item The prover, on inputs $k, evk, y$, generates classical ``commitment" $m$ and internal state $\ket{st}$.
			It sends $m$ to the verifier.
		\item The verifier sends the prover a public fair coin $c\in{0,1}$.
		\item The prover, on inputs $c$ and $\ket{st}$, generates classical $a$ and sends it to the verifier.
		\item The verifier, on inputs $k, td, m, c, a, sk$, generates and outputs either $acc$ or $rej$.
	\end{enumerate}
\end{protocol}

$k$ has the additional properties to not leak information on $\Lambda'$, so the compliation preserves blindness. \Ethan{How to make this more rigorous?}

We then apply the recent result parallel repetition get negligible soundness again:

\begin{protocol}{Parallel repetition of \cref{proto:QPIP0BQP}}
	\label{proto:repQPIP0BQP}
	\Ethan{TODO PROOFREAD ME}
	Run $m=\poly(n)$ copies of \cref{proto:QPIP0BQP} in parallel. Accept if the proportion of accepted copies is over some certain threshold $p(n)\in(0, 1)$.

\end{protocol}

\begin{thm}
	\cref{proto:repQPIP0BQP} has negligible completeness and soundness
\end{thm}
\begin{prf}
	See \cite{parallelrep} \Ethan{TODO FIND AND CITE the other parallel rep. paper}
\end{prf}

\subsection{Blind delegation of FBQP}

\Ethan{TODO PROOFREAD ME}

Our results for $\BQP$ can be generalized to $\FBQP$.

Let $f\in\FBQP$.
For any input $x\in\set{0, 1}^*$, define $f_i(x)$ to be the $i$-th bit of $f(x)$.
For $i\in\bbN, b\in\set{0,1}$, define the language $L_{i, b}=\set{x:f_i(x)=b}$.
Define $\cL$ to be the collection of these languages: $\cL = \set{L_{i, b}: i\in[m], b\in\set{0, 1}}$.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{proto:QPIP0FBQP}
	Input: $x\in\set{0, 1}^n$

	Suppose without loss of generality that the verifier knows $f(x)$ is of length $m=\poly(n)$ \Ethan{Seems like a strong assumption; maybe need to explain how?}
	\begin{enumerate}
		\item Run \cref{proto:repQPIP0BQP} for all $L\in\cL$ in parallel using input $x$. The verifier gets outputs $v_{i, b}\in\set{Acc, Rej}$.
		\item If $\exists i$ s.t. $v_{i,0}=v_{i,1}$, reject.
		\item Otherwise, define $y_i = b$ where $v_{i, b}=Acc$. This gives $y\in\set{0,1}^m$
		\item Verifier outputs $y$
	\end{enumerate}
\end{protocol}

\begin{theorem}
	\Cref{proto:QPIP0FBQP} has negligible completeness and soundness, and is blind.
\end{theorem}
\begin{prf}
	Completeness is follows by inspection.
	Blindness follows because the executions of \cref{proto:repQPIP0BQP} are blind.

	Based on the soundness of \cref{proto:BlindBQP}, $v_{i, b}=Acc$ implies that $x\in L_{i, b}\Rightarrow f_i(x)=b$ with overwhelming probability.
	In other words, $y_i$ is correct with probability $1-\varepsilon_i$ where $\varepsilon_i=\negl(n)$. 
	
	By union bound over all output bits, the soundness of \cref{proto:QPIP0FBQP} is then
	$\sum_{i=1}^m \varepsilon_i$
	which is clearly negligible.
\end{prf}
