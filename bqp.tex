\section{Constant-Round Blind Delegation for BQP}
\label{sec:BlindBQP}

In this section we present our constant-round blind delegation protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

\begin{thm}
	\Ethan{Main theorem of the section}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}

We'll construct this protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.

Let $L\in\BQP$, and $x\in\set{0,1}^*$.

There exists some certificate for both $x\in L$ and $x\notin L\Rightarrow x\in\overline{L}$, since $L, \overline{L}\in\QMA$.
In fact, they have the same certificate, which we'll call $\ket{\psi_x}$. See the excellent text \cite{kitaev2002classical} for details.
According to \cite{PhysRevA.93.022326}, the certificate can be check using only $X$ and $Z$ measurements.
We'll also summarize said proofs in \cref{sec:Hamiltonian} for our $\SampBQP$ construction.

\begin{thm}
	Let $n$ be large enough to achieve negligible completeness and soundness for the corresponding $\QMA$ certificate checks.
	Then \protoref{BQP} is a $\QPIP_1$ and constant round protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}

\floatname{algorithm}{Protocol}
\begin{algorithm}
	\caption{Protocol for $\BQP$}
	\label{proto:BQP}
	\begin{algorithmic}[1]
		\State The verifier sends $x$ to the prover
		\State The prover sends $2n$ copies of $\ket{\psi_x}$ to the verifier
		\State The verifier uses $n$ copies to check for $x\in L$, and the other $n$ copies to check for $x\in\overline{L}$
	\end{algorithmic}
\end{algorithm}

Now we generalize the previous construction to achieve blindness.
We denote the prover's action as $\cF$. That is, $\cF(x)=\ket{\psi_x}^{\otimes 2n}$.

\begin{algorithm}
	\caption{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	\begin{algorithmic}[1]
		\State Let $\lambda$ be the security parameter.
		\State Let $L$ be the depth of the circuit corresponding to $\cF$
		\State Let $n$ be large enough to achieve negligible completeness and soundness for the corresponding $\QMA$ certificate checks.
		\State The verifier runs $\mathsf{QHE.Keygen}(\lambda, L)$ to get $pk, sk$.
		\State The verifier encrypts $x$ to get $\mathsf{QHE.Enc}_{pk}(x)$
		\State The verifier sends $c=\mathsf{QHE.Enc}_{pk}(x)$ and $pk$ to the prover
		\State The prover sends $\mathsf{QHE.Eval}(\cF, c)$ to the verifier
		\State The verifier measures the incoming ciphertext according to \autoref{decodeMeasureOrder} and how it would've checked the $\QMA$ certificates
		\State The verifier decodes the measurement results
		\State The verifier uses $n$ copies to check for $x\in L$, and the other $n$ copies to check for $x\in\overline{L}$
	\end{algorithmic}
\end{algorithm}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and IND-CPA protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\protoref{BlindBQP} has negligible completeness
\end{thm}
\begin{proof}
	Based on the correctness of $\mathsf{QHE}$, the verifier would successfully decode $\cF(c)$ with overwhelming probability.
	The subsequent underlying QMA check also has overwhelming probability of acceptance.
\end{proof}

\begin{thm}
	\protoref{BlindBQP} has negligible soundness
\end{thm}
\begin{proof}
	The verifier's actions is equivalent to first decoding the prover's message then measuring it.

	Suppose the prover's message decodes to some $\rho$. Since it is a quantum state, the soundness of the underlying $\QMA$ instance can be used.
	
	That is, there doesn't exists a valid certificate $\rho$ that has non-negligible probability of acceptance.
\end{proof}

\begin{thm}
	\protoref{BlindBQP} is IND-CPA
\end{thm}
\begin{proof}
	The only thing the prover learns is $c$ and $pk$, so this follows directly from $\mathsf{QHE}$'s security.
\end{proof}

Now we can simply apply the following results from \cite{parallelrep} to obtain a blind and constant-round for $\QPIP_0$ with negligible completeness and soundness.
\begin{thm}
	There is a compiler that takes a $\QPIP_1$ protocol with the following properties:
	\begin{itemize}
		\item classical inputs
		\item client uses only X/Z measurements
		\item negl. completeness and soundness
	\end{itemize}
	and outputs a corresponding $\QPIP_0$ protocol with negl. completeness and soundness \Ethan{same inputs...?}
\end{thm}

\floatname{algorithm}{Algorithm}
