\section{Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP}

\def\MF{\mathsf{MF}}
\nc{\PiMF}{\ensuremath{\Pi_\MF}}
\nc{\VMF}{\ensuremath{V_\MF}}
\nc{\PMF}{\ensuremath{P_\MF}}
\nc{\PMFstar}{\ensuremath{P_\MF^*}}
\nc{\cVMF}[1]{\ensuremath{\cV_{\MF,#1}}}
\nc{\cPMF}[1]{\ensuremath{\cP_{\MF,#1}}}

\def\blind{\mathsf{blind}}
\nc{\Piblind}{\ensuremath{\Pi_\blind}}
\nc{\Vblind}{\ensuremath{V_\blind}}
\nc{\Pblind}{\ensuremath{P_\blind}}
\nc{\Pblindstar}{\ensuremath{P_\blind^*}}
\nc{\cVblind}[1]{\ensuremath{\cV_{\blind,#1}}}
\nc{\cPblind}[1]{\ensuremath{\cP_{\MF,#1}}}

\def\bz{\mathsf{blind, 0}}
\nc{\Pibz}{\ensuremath{\Pi_\bz}}
\nc{\Vbz}{\ensuremath{V_\bz}}
\nc{\Pbz}{\ensuremath{P_\bz}}

\def\bzrep{\mathsf{blind, 0, rep}}
\nc{\Pibzrep}{\ensuremath{\Pi_\bzrep}}

\Ethan{TODO Intro this section}

\subsection{Blind Delegation for BQP}
\label{subsec:BlindBQP}

In this subsection we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

We start with a high-level description of the $\QPIP_1$ scheme $\PiMF$ from \cite{FOCS:Mahadev18a}, which is in turn taken from \cite{mf16}.

This is a one-message $\QPIP_1$ protocol with only $X$ and $Z$ measurement for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a $m$-qubit certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a product measurement $\Lambda$ of $X$ and $Z$s according to a certain distribution, and applies it to $\rho$.
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol $\PiMF = (\PMF, \VMF)$ for $\BQP$ language $L$}
	\label{proto:BQP}
	Common input: $x\in\set{0,1}^n$. 
	\begin{enumerate}
		\item The prover generates a certificate state $\rho\leftarrow\cPMF{1}(x)$  and sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier generates $\Lambda \leftarrow \cVMF{2}(x)$, where $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$;
			each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement and $m=\poly(n)$ is the length of the prover's certificate state.
			It applies $\Lambda$ to $\rho$ qubit-by-qubit.
			Let $w \in \set{0,1}^m$ denote the measurement outcome.
			It verifies the measurement outcome and produces a decision $o\leftarrow\cVMF{3}(x, \Lambda, w)$ where $o\in\set{acc, rej}$ and $\cVMF{3}$ is a classical polynomial-time algorithm.
	\end{enumerate}
\end{protocol}

$\PiMF$ has negligible completeness and soundness.

We compile $\PiMF$ using Mahadev's $\QHE$ from \cite{mahadev_qfhe} to obtain a blind 1-message $\QPIP_1$ protocol $\Piblind$ for $\BQP$, again with only $X$ and $Z$ measurements.
The high level idea is to run $\PiMF$ under $\mathsf{QHE}$.
Namely, the verifier encrypts its original input $x$ and sends $y=\mathsf{QHE.Enc}(x)$ to the prover.
The prover then homomorphically evaluates $\cF$ on $y$ to produce $\sigma$ and sends it to the verifier.

Now the verifier needs to obtain the measurement outcome $w$ from the encrypted state $\sigma$ using qubit-by-qubit $X$ and $Z$ measurements.
This may not be possible in general, but we observe that $\mathsf{QHE}$ allows this. 
Its ciphertexts consists of a Pauli one-time-padded plaintext and classically encrypted Pauli keys.
Pauli one-time-pads commute with $X$ and $Z$ measurements, so the verifier can measure the one-time-padded state as usual, then correct the measurement results using the Pauli keys.
Now we state and prove this observation in more precise terms.

\Ethan{TODO PROOFREAD ME}
\begin{thm}
	\label{decodeMeasureOrder}
	Let $n\in\bbN$.
	Let $m\in\bbN$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.

	There exists efficient classical poly-time algorithms $\cM_\QHE$ and $\widehat{\mathsf{QHE.Dec}}$ s.t.
	for all $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$ where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement:
	$$\cM_\QHE(\Lambda)=\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$$
	where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{prf}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$
	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $u=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $u$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $u$ to get $\Lambda(\rho)$.
\end{prf}

Now we state our results of compiling $\PiMF$ using $\mathsf{QHE}$:

\begin{protocol}{Blind $\QPIP_1$ 1-message protocol $\Piblind = (\Pblind, \Vblind)$ for $\BQP$ language $L$}
	\label{proto:BlindBQP}
	Verifier's input: $x\in\set{0,1}^n$.
	
	Let $d=\poly(n)$ be the depth of the circuit corresponding to $\cPMF{1}$.
	\begin{enumerate}
		\item The verifier generates $(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$, where $d$ is the depth of the circuit corresponding to $\cPMF{1}(x)$.
			It then generates and sends $ct_x\leftarrow\mathsf{QHE.Enc}_{pk}(x)$ to the prover.
			It also sends $evk$ to the prover.
		\item The prover homomorphically evaluates $\cPMF{1}$ on input $ct_x$, generating $\sigma\leftarrow\mathsf{QHE.Eval}_{evk}(\cPMF{1}, ct_x)$.
			It sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier generates $\Lambda\leftarrow\cVMF{2}(x)$,
			$\Lambda'\leftarrow\cM_\QHE$,
			$ct_w\leftarrow\Lambda'(\sigma)$,
			$w\leftarrow\widehat{\mathsf{QHE.Dec}_{sk}}(ct_w)$,
			and $o\leftarrow\cVMF{3}(x, \Lambda, w)$.
			It outputs $o$.
	\end{enumerate}
\end{protocol}

\begin{thm}
	\label{thm:BlindBQP}
	$\Piblind$ has negligible completeness and soundness, and is blind.
\end{thm}
\begin{prf}
	The completeness follows by inspection.
	For blindness, the only thing the prover sees is $c$ and $evk$, so it follows directly from $\mathsf{QHE}$'s security.
	
	Suppose for the sake of contradiction that there exists some cheating prover $\Pblindstar$ with some noticeable acceptance probability $\varepsilon$.

	Then we can construct a prover $\PMFstar$ violating the soundness guarantees of $\PiMF$ by simulating $(\Vblind(x), \Pblindstar)$ as below:

	We define $\PMFstar$ to first generate
	$(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$
	and
	$y\leftarrow\mathsf{QHE.Enc}_{pk}(x)$
	It then sends $y$ and $evk$ to $\Pblindstar$ and gets $\sigma$ back.
	Finally, it decrypts
	$\rho\leftarrow\mathsf{QHE.Dec}_{sk}(\sigma)$
	and sends it to $\VMF$ qubit-by-qubit.

	We now prove that $\PMFstar$ in fact violates the soundness of $\PiMF$.
	Let $\cP_\blind^*$ denote the action $\Pblindstar$ takes to produce $\sigma$ from $ct_x$.
	Consider the experiment corresponding to $\Piblind$:
	$$(pk, sk, evk)\leftarrow\QGen(1^n, 1^d)$$
	$$ct_x\leftarrow\QEnc_{pk}(x)$$
	$$\sigma\leftarrow\cP_\blind^*(ct_x, evk)$$
	$$\Lambda\leftarrow\cVMF{2}(x)$$
	$$\Lambda'\leftarrow\cM_\QHE(\Lambda)$$
	$$ct_w\leftarrow\Lambda'(\sigma)$$
	$$w\leftarrow\widehat{\QDec_{sk}}(ct_w)$$
	$$o\leftarrow\cVMF(x, \Lambda, w)$$

	Compare it with the experiment corresponding to $\PMFstar$:
	$$(pk, sk, evk)\leftarrow\QGen(1^n, 1^d)$$
	$$ct_x\leftarrow\QEnc_{pk}(x)$$
	$$\sigma\leftarrow\cP_\blind^*(ct_x, evk)$$
	$$\Lambda\leftarrow\cVMF{2}(x)$$
	$$\rho\leftarrow\QDec_{sk}(\sigma)$$
	$$w\leftarrow\Lambda(\rho)$$
	$$o\leftarrow\cVMF(x, \Lambda, w)$$

	By inspection, the only difference between the experiments is how $w$ is obtained from $\sigma$.
	By \cref{decodeMeasureOrder}, the two ways are equivalent.
\end{prf}

\Ethan{TODO Below is copied from google docs; fix phrasing later}

Finally, we prove \cref{thm:QPIP0BQP}.
We use Mahadev's measurement protocol from \cite{FOCS:Mahadev18a} which can compile any $\QPIP_1$ protocol with X, Z measurement and negligible soundness to a $\QPIP_0$ protocol.
The resulting protocol $\Pibz$ is a constant-round $\QPIP_0$ protocol with soundness error $\frac{3}{4} + \negl(n)$ and negligible completeness.

In order to prove blindness, we give a high-level overview of the compiliation results.
\Ethan{Need to discuss about this}

\begin{protocol}{Blind $\QPIP_0$ protocol $\Pibz$ for $BQP$ language $L$}
	\label{proto:QPIP0BQP}
	\begin{enumerate}
		\item The verifier generates $\Lambda, \Lambda', pk, sk, evk, ct_x$ the same way as in \cref{proto:BlindBQP}. \Ethan{Need more notation? But how?}
			Then, using $\Lambda'$, it generates $k, td$.
			It sends $k, evk, ct_x$ to the prover.
		\item The prover, on inputs $k, evk, ct_x$, generates classical ``commitment" $y$ and internal state $\ket{st}$.
			It sends $y$ to the verifier.
		\item The verifier sends the prover a public coin $c\in\set{0,1}$.
		\item The prover, on inputs $c$ and $\ket{st}$, generates classical $a$ and sends it to the verifier.
		\item The verifier, on inputs $k, td, y, c, a, sk$, generates and outputs either $acc$ or $rej$.
	\end{enumerate}
\end{protocol}

\Ethan{
    Need to say more about step 5.
    It's a compiler here.
    Need to say stuff about interface
    see protocol 5.1; protocol is the most important
    interface uses only lambda
    if hadamard round, get measurement outcome corresponding to sigma
    how to decode
    
    Describe in words what's 5.1
    Leave author note for theorem for now
}

$k$ has the additional properties to not leak information on $\Lambda'$, so the compliation preserves blindness. \Ethan{How to make this more rigorous?}

We then apply the recent result parallel repetition get negligible soundness again:

\begin{protocol}{Parallel repetition of \cref{proto:QPIP0BQP}}
	\label{proto:repQPIP0BQP}
	\Ethan{TODO PROOFREAD ME}
	Run $m=\poly(n)$ copies of \cref{proto:QPIP0BQP} in parallel. Accept if the proportion of accepted copies is over some certain threshold $p(n)\in(0, 1)$.

\end{protocol}

\begin{thm}
	\cref{proto:repQPIP0BQP} has negligible completeness and soundness
\end{thm}
\begin{prf}
	See \cite{parallelrep, alagic2019twomessage}
\end{prf}

\subsection{Blind delegation of FBQP}

\Ethan{TODO PROOFREAD ME}

Our results for $\BQP$ can be generalized to $\FBQP$.

Let $f\in\FBQP$.
For any input $x\in\set{0, 1}^*$, define $f_i(x)$ to be the $i$-th bit of $f(x)$.
For $i\in\bbN, b\in\set{0,1}$, define the language $L_{i, b}=\set{x:f_i(x)=b}$.
Furthermore, define $\cL$ to be the collection of these languages: $\cL = \set{L_{i, b}: i\in[m], b\in\set{0, 1}}$.

\begin{protocol}{Blind and verifiable $\QPIP_0$ protocol $\Pi_{\FBQP}$ for $\FBQP$ language $L$}
	\label{proto:QPIP0FBQP}
	Input: $x\in\set{0, 1}^n$

	Suppose without loss of generality that the verifier knows $f(x)$ is of length $m=\poly(n)$ \Ethan{Seems like a strong assumption; maybe need to explain how?}
	\begin{enumerate}
		\item Run $\Pibzrep$ for all $L\in\cL$ in parallel using input $x$.
		\item The verifier gets outputs $v_{i, b}\in\set{acc, rej}$.
			If $\exists i$ s.t. $v_{i,0}=v_{i,1}$, reject.
			Otherwise, define $y_i = b$ where $v_{i, b}=acc$. This gives $y\in\set{0,1}^m$.
			The verifier accepts and outputs $y$.
	\end{enumerate}
\end{protocol}

\begin{theorem}
	$\Pi_{\FBQP}$ has negligible completeness and soundness, and is blind.
\end{theorem}
\begin{prf}
	Completeness is follows by inspection.
	Blindness follows because the executions of \cref{proto:repQPIP0BQP} are blind.

	By the soundness of $\Pibzrep$, $v_{i, b}=acc$ implies that $x\in L_{i, b}\Rightarrow f_i(x)=b$ with overwhelming probability.
	In other words, $y_i$ is correct with probability $1-\varepsilon_i$ where $\varepsilon_i=\negl(n)$. 
	
	By union bound over all output bits, the soundness of \cref{proto:QPIP0FBQP} is then
	$\sum_{i=1}^m \varepsilon_i$
	which is clearly negligible.
\end{prf}
