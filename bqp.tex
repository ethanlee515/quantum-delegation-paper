\section{Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP}

\def\MF{\mathsf{MF}}
\nc{\PiMF}{\ensuremath{\Pi_\MF}}
\nc{\VMF}{\ensuremath{V_\MF}}
\nc{\PMF}{\ensuremath{P_\MF}}
\nc{\PMFstar}{\ensuremath{P_\MF^*}}
\nc{\cVMF}[1]{\ensuremath{\cV_{\MF,#1}}}
\nc{\cPMF}[1]{\ensuremath{\cP_{\MF,#1}}}

\def\blind{\mathsf{blind}}
\nc{\Piblind}{\ensuremath{\Pi_\blind}}
\nc{\Vblind}{\ensuremath{V_\blind}}
\nc{\Pblind}{\ensuremath{P_\blind}}
\nc{\Pblindstar}{\ensuremath{P_\blind^*}}
\nc{\cVblind}[1]{\ensuremath{\cV_{\blind,#1}}}
\nc{\cPblind}[1]{\ensuremath{\cP_{\MF,#1}}}

\Ethan{TODO Read other papers and see if I can copy their tones and phrasing}

\Ethan{Note to self: If the original is wordy, just keep it the way it is. Don't try to simplify existing dfns.}

\Ethan{TODO Intro this section}

\Ethan{See https://www.iis.sinica.edu.tw/~kmchung/download/ConstCZK.pdf for conventions. Mal. parties have stars, protos use Pi. Stuff like $r(P(w), V )(1n ,(M, x, t))$ }

\Ethan{More notation, fix interfaces}

\Ethan{Fix up to proto 3 and proofs}

\subsection{Blind Delegation for BQP}
\label{subsec:BlindBQP}

In this subsection we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

We start with a high-level description of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which is in turn taken from \cite{mf16}.

This is a one-message $\QPIP_1$ protocol with only $X$ and $Z$ measurement for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a $m$-qubit certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a product measurement $\Lambda$ of $X$ and $Z$s according to certain distribution to apply to $\rho$
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol $\PiMF = (\PMF, \VMF)$ for $\BQP$ language $L$}
	\label{proto:BQP}
	Common input: $x\in\set{0,1}^n$. 
	\begin{enumerate}
		\item The verifier generates $\Lambda \leftarrow \cVMF{1}(x)$, where $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$; each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement and $m=\poly(n)$ is the length of the prover's certificate state. \Ethan{Switch steps 1 and 2}
		\item The prover generates a certificate state $\rho\leftarrow\cPMF{2}(x)$  and sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier applies the measurement $\Lambda$ to $\rho$ qubit-by-qubit.
			Let $w \in \set{0,1}^m$ denote the measurement outcome.
			It verifies the measurement outcome and produces a decision $o\leftarrow\cVMF{3}(x, \Lambda, w)$ where $o\in\set{acc, rej}$ and $\cVMF{3}$ is a classical polynomial-time algorithm.
	\end{enumerate}
\end{protocol}

We compile this protocol using Mahadev's $\mathsf{QHE}$ from \cite{mahadev_qfhe} to obtain a blind 1-message $\QPIP_1$ protocol for $\BQP$, again with only $X$ and $Z$ measurements.
The high level idea is to run \cref{proto:BQP} under $\mathsf{QHE}$.
Namely, the verifier encrypts its original input $x$ and sends $y=\mathsf{QHE.Enc}(x)$ to the prover.
The prover then homomorphically evaluate $\cF$ on $y$ to produce $\sigma=\mathsf{QHE.Enc}(\rho)$ \Ethan{Is this actually ok? $\sigma$ is a ciphertext corresponding to $\rho$, but it wasn't encrypted. In fact it's deteriorated due to homomorphic eval} and send it back to the verifier.

Now the verifier needs to obtain the measurement outcome $w$ from the encrypted state $\sigma$ using qubit-by-qubit $X$ and $Z$ measurements.
This may not be possible in general, but we observe that $\mathsf{QHE}$ allows this. 
Its ciphertexts consists of a Pauli one-time-padded plaintext and classically encrypted Pauli keys.
Pauli one-time-pads commute with $X$ and $Z$ measurements, so the verifier can measure the one-time-padded state as usual then correct the measurement results using the Pauli keys.
We state this observation as the following theorem:

\begin{thm}
	\label{decodeMeasureOrder}
	Let $sk$ be some secret key of $\mathsf{QHE}$.
	Let $n\in\bbN$.
	Let $m\in\bbN$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.
	Let $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$, where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.

	There exists $\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$ where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and polynomial-time algorithm $\widehat{\mathsf{QHE.Dec}}$ such that:
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{prf}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$

	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $u=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $u$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $u$ to get $\Lambda(\rho)$.
\end{prf}

\Ethan{Give the theorem above a corresponding algorithm}

\Cref{proto:BQP} has negligible completeness and soundness.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\begin{protocol}{Blind $\QPIP_1$ 1-message protocol $\Piblind = (\Pblind, \Vblind)$ for $\BQP$ language $L$}
	\label{proto:BlindBQP}
	Verifier's input: $x\in\set{0,1}^n$.
	
	Let $d=\poly(n)$ be the depth of the circuit corresponding to $\cPMF{2}$.
	\begin{enumerate}
		\item The verifier generates $\Lambda\leftarrow\cVMF{1}(x)$.
			On input $\Lambda$, it computes $\Lambda'$ using \cref{decodeMeasureOrder}.
			Then it generates $(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$ and $y\leftarrow\mathsf{QHE.Enc}_{pk}(x)$.
			It sends $y$ and $evk$ to the prover.
			\Ethan{Do two steps. Keygens first, lambda next. For keygen step, say more in words and describe $d$. Remember to specify $x$ when talking about $d$ and $\cPMF{2}$}
		\item The prover homomorphically evaluates $\cPMF{2}$ on input $y$, generating $\sigma\leftarrow\mathsf{QHE.Eval}(\cPMF{2}, y)$.
			It sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier generates $ct\leftarrow\Lambda'(\sigma)$,
			$w\leftarrow\widehat{\mathsf{QHE.Dec}_{sk}}(ct)$,
			and then $o\leftarrow\cVMF{3}(x, \Lambda, w)$.
			It outputs $o$.
	\end{enumerate}
\end{protocol}

\Ethan{Change steps orders above. 1. verifier enc and send y 2. prover sends something back 3. verifier sample lambda}

As we will prove, $\Piblind$ is a $\QPIP_1$, constant round, and blind protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	$\Piblind$ has negligible completeness and soundness, and is blind.
\end{thm}
\begin{prf}
	The completeness follows by inspection.
	For blindness, the only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.
	
	Suppose for the sake of contradiction that there exists some cheating prover $\Pblindstar$ violating the soundness guarantees of $\Piblind$ 
	\Ethan{Define some $\epsilon$ here. Also ``non-negligible" = ``noticeable"},
	then we can use it to construct a prover $\PMFstar$ violating the soundness guarantees of $\PiMF$.

	\Ethan{This construction is too small for a separate box but maybe still be too big to just write it like this?}
	
	\Ethan{Add the ``simulate" thing back}

	We define $\PMFstar$ to first generate
	$(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}$
	and
	$y\leftarrow\mathsf{QHE.Enc}_{pk}(x)$
	It then sends $y$ and $evk$ to $\Pblindstar$ and gets $\sigma$ back.
	Finally, it decrypts
	$\rho\leftarrow\mathsf{QHE.Dec}_{sk}(\sigma)$
	and sends it to $\VMF$ qubit-by-qubit.

    \Ethan{Rewrite the following proof again; write in terms of interactions this time. See google docs. Same success probability. Compare interactions}
    
	We now prove that $\PMFstar$ in fact violates the soundness of $\PiMF$.
    By assumption, $\Vblind$ has a non-negligible probability to accept after receiving $\sigma$.
	In other words, let $\Lambda\leftarrow\cVMF{1}$, and define $\Lambda'$ by \cref{decodeMeasureOrder},
    \Ethan{Give theorem 3.2 an algorithm}
	then with non-negligible probability
	$$\cVMF{3}(x, \Lambda, \widehat{\mathsf{QHE.Dec}_{sk}}(\Lambda'(\sigma))=acc$$
	which is equivalent to
	$$\cVMF{3}(x, \Lambda, \Lambda(\rho))=acc$$
	That is, $\PMFstar$ violates the soundness of $\PiMF$.
\end{prf}

\Ethan{TODO Below is copied from google docs; fix phrasing later}

Finally, we prove Thm 3.1 by applying Mahadev's measurement protocol~\cite{mahadev_delegation} to Protocol 3 to compile it into a $\QPIP_0$ protocol $(P', V')$ \Ethan{fix name}.
Note that Mahadev's measurement protocol can compile any $\QPIP_1$ protocol with X, Z measurement and negligible soundness to a $\QPIP_0$ protocol, and Protocol 3 is a $\QPIP_1$ protocol with X, Z measurement and negligible soundness.
Thus the resulting protocol $(P', V')$ is a O(1)-round $\QPIP_0$ protocol with soundness error $\frac{3}{4} + \negl(n)$

We give a high-level overview of the compiliation results. \Ethan{Maybe just delete it and give name only}

\begin{protocol}{\Cref{proto:BlindBQP} compiled using Mahadev's measurement protocol \Ethan{Give this a name}}
	\label{proto:QPIP0BQP}
	\begin{enumerate}
		\item The verifier generates $\Lambda, \Lambda', pk, sk, evk, y$ the same way as in \cref{proto:BlindBQP}. \Ethan{Need more notation? But how?}
			Then, using $\Lambda'$, it generates $k, td$.
			It sends $k, evk, y$ to the prover.
		\item The prover, on inputs $k, evk, y$, generates classical ``commitment" $m$ and internal state $\ket{st}$.
			It sends $m$ to the verifier.
		\item The verifier sends the prover a public coin $c\in\set{0,1}$.
		\item The prover, on inputs $c$ and $\ket{st}$, generates classical $a$ and sends it to the verifier.
		\item The verifier, on inputs $k, td, m, c, a, sk$, generates and outputs either $acc$ or $rej$.
	\end{enumerate}
\end{protocol}

\Ethan{
    Need to say more about step 5.
    It's a compiler here.
    Need to say stuff about interface
    see protocol 5.1; protocol is the most important
    interface uses only lambda
    if hadamard round, get measurement outcome corresponding to sigma
    how to decode
    
    Describe in words what's 5.1
    Leave author note for theorem for now
}

$k$ has the additional properties to not leak information on $\Lambda'$, so the compliation preserves blindness. \Ethan{How to make this more rigorous?}

We then apply the recent result parallel repetition get negligible soundness again:

\begin{protocol}{Parallel repetition of \cref{proto:QPIP0BQP}}
	\label{proto:repQPIP0BQP}
	\Ethan{TODO PROOFREAD ME}
	Run $m=\poly(n)$ copies of \cref{proto:QPIP0BQP} in parallel. Accept if the proportion of accepted copies is over some certain threshold $p(n)\in(0, 1)$.

\end{protocol}

\begin{thm}
	\cref{proto:repQPIP0BQP} has negligible completeness and soundness
\end{thm}
\begin{prf}
	See \cite{parallelrep} \Ethan{TODO FIND AND CITE the other parallel rep. paper}
\end{prf}

\subsection{Blind delegation of FBQP}

\Ethan{TODO PROOFREAD ME}

Our results for $\BQP$ can be generalized to $\FBQP$.

Let $f\in\FBQP$.
For any input $x\in\set{0, 1}^*$, define $f_i(x)$ to be the $i$-th bit of $f(x)$.
For $i\in\bbN, b\in\set{0,1}$, define the language $L_{i, b}=\set{x:f_i(x)=b}$.
Define $\cL$ to be the collection of these languages: $\cL = \set{L_{i, b}: i\in[m], b\in\set{0, 1}}$.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{proto:QPIP0FBQP}
	Input: $x\in\set{0, 1}^n$

	Suppose without loss of generality that the verifier knows $f(x)$ is of length $m=\poly(n)$ \Ethan{Seems like a strong assumption; maybe need to explain how?}
	\begin{enumerate}
		\item Run \cref{proto:repQPIP0BQP} for all $L\in\cL$ in parallel using input $x$. The verifier gets outputs $v_{i, b}\in\set{Acc, Rej}$.
		\item If $\exists i$ s.t. $v_{i,0}=v_{i,1}$, reject.
		\item Otherwise, define $y_i = b$ where $v_{i, b}=Acc$. This gives $y\in\set{0,1}^m$
		\item Verifier outputs $y$
	\end{enumerate}
\end{protocol}

\begin{theorem}
	\Cref{proto:QPIP0FBQP} has negligible completeness and soundness, and is blind.
\end{theorem}
\begin{prf}
	Completeness is follows by inspection.
	Blindness follows because the executions of \cref{proto:repQPIP0BQP} are blind.

	Based on the soundness of \cref{proto:BlindBQP}, $v_{i, b}=Acc$ implies that $x\in L_{i, b}\Rightarrow f_i(x)=b$ with overwhelming probability.
	In other words, $y_i$ is correct with probability $1-\varepsilon_i$ where $\varepsilon_i=\negl(n)$. 
	
	By union bound over all output bits, the soundness of \cref{proto:QPIP0FBQP} is then
	$\sum_{i=1}^m \varepsilon_i$
	which is clearly negligible.
\end{prf}
