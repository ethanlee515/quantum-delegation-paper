\section{Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP}

\Ethan{TODO Read other papers and see if I can copy their tones and phrasing}

\Ethan{Note to self: If the original is wordy, just keep it the way it is. Don't try to simplify existing dfns.}

\Ethan{TODO Intro this section}

\subsection{Blind Delegation for BQP}
\label{subsec:BlindBQP}

In this subsection we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

We start with a high-level description of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which is in turn taken from \cite{mf16}.

This is a one-message $\QPIP_1$ protocol with only $X$ and $Z$ measurement for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a $m$-qubit certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a product measurement $\Lambda$ of $X$ and $Z$s according to certain distribution to apply to $\rho$
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol for $\BQP$ language $L$}
	\label{proto:BQP}
	Input: $x\in\set{0,1}^n$.
	\Ethan{Consider more notation $V_1$, $P_2$... See parallel rep paper. Numbering like this works better for compilers}
	\Ethan{Use terms like ``generate" or arrows; see google docs}
	\begin{enumerate}
		\item On input $x$, the verifier samples $\Lambda$ from a certain distribution $\pi_x$, where $m=\poly(n)$, $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$; each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.
		\item The verifier sends $x$ to the prover.
		\item The prover applies an algorithm $\cF$ \Ethan{Probably P3 or maybe a ``meaningful" name} on $x$ to generate $\rho\in\cB^{\otimes m}$.
		\item The prover sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming qubits of $\rho$ according to $\Lambda$ to get $w$.
		\item The verifier runs some polynomial-time algorithm $\cV$ on input $w$ and outputs either accept or reject.
	\end{enumerate}
\end{protocol}

We compile this protocol using Mahadev's $\mathsf{QHE}$ from \cite{mahadev_qfhe} to obtain a blind 1-message $\QPIP_1$ protocol for $\BQP$, again with only $X$ and $Z$ measurements.
The high level idea is to run \cref{proto:BQP} under $\mathsf{QHE}$.
Namely, the verifier encrypts its original input $x$ and sends $y=\mathsf{QHE.Enc}(x)$ to the prover.
The prover then homomorphically evaluate $\cF$ on $y$ to produce $\sigma=\mathsf{QHE.Enc}(\rho)$ \Ethan{Is this actually ok? $\sigma$ is a ciphertext corresponding to $\rho$, but it wasn't encrypted. In fact it's deteriorated due to homomorphic eval} and send it back to the verifier.

Now the verifier needs to obtain the measurement outcome $w$ from the encrypted state $\sigma$ using qubit-by-qubit $X$ and $Z$ measurements.
This may not be possible in general, but we observe that $\mathsf{QHE}$ allows this. 
Its ciphertexts consists of a Pauli one-time-padded plaintext and classically encrypted Pauli keys.
Pauli one-time-pads commute with $X$ and $Z$ measurements, so the verifier can measure the one-time-padded state as usual then correct the measurement results using the Pauli keys.
We state this observation as the following theorem:

\begin{thm}
	\label{decodeMeasureOrder}
	Let $sk$ be some secret key of $\mathsf{QHE}$.
	Let $n\in\bbN$.
	Let $m\in\bbN$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.
	Let $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$, where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.

	There exists $\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$ where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and polynomial-time algorithm $\widehat{\mathsf{QHE.Dec}}$ such that:
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{prf}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$

	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $u=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $u$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $u$ to get $\Lambda(\rho)$.
\end{prf}

\cref{proto:BQP} has negligible completeness and soundness.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\begin{protocol}{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	Let $x\in\set{0,1}^n$.
	Let $d=\poly(n)$ be the depth of the circuit corresponding to $\cF$.
	Take $\pi_{L, x}$, $\cF$, and $\cV$ to be the same as in \cref{proto:BQP}
	\begin{enumerate}
		\item The verifier samples $\Lambda$ from $\pi_{L, x}$
		\item The verifier computes $\Lambda'$ using \cref{decodeMeasureOrder}
		\item The verifier computes $(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$.
		\item The verifier computes $y=\mathsf{QHE.Enc}_{pk}(x)$
		\item The verifier sends $y$ and $evk$ to the prover
		\item The prover computes $\sigma=\mathsf{QHE.Eval}(\cF, y)$
		\item The prover sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext according to $\Lambda'$, getting $ct$
		\item The verifier applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to $ct$, getting $w$.
		\item The verifier applies $\cV$ to $w$ and outputs its result.
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and blind protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\cref{proto:BlindBQP} has negligible completeness and soundness, and is blind.
\end{thm}
\begin{prf}
	The completeness follows by inspection.
	For blindness, the only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.

    \Ethan{rewrite the following as a reduction. If exists adversary $P*$ that breaks soundness of this protocol, construct $P**$ that breaks the other one...}

	For soundness, suppose the prover sends $\sigma$.
    
	The verifier's actions, by \cref{decodeMeasureOrder}, is $\negl(n)$-close to to decoding $\sigma$ to get some $\rho$ then applying $\Lambda$ to get $w$.
	In other words, the verifier's outputs is $\negl(n)$-close to the verifer of \cref{proto:BQP} under the same input and receiving $\rho$ from the prover.
	So the conclusion follows from the negligible soundness of \cref{proto:BQP}.
\end{prf}

\Ethan{Below is copied from google docs}

Finally, we prove Thm 3.1 by applying Mahadev's measurement protocol~\cite{mahadev_delegation} to Protocol 3 to compile it into a $\QPIP_0$ protocol $(P', V')$ \Ethan{fix name}.
Note that Mahadev's measurement protocol can compile any $\QPIP_1$ protocol with X, Z measurement and negligible soundness to a $\QPIP_0$ protocol, and Protocol 3 is a $\QPIP_1$ protocol with X, Z measurement and negligible soundness.
Thus the resulting protocol $(P', V')$ is a O(1)-round $\QPIP_0$ protocol with soundness error $\frac{3}{4} + \negl$ \Ethan{Write what is it negl in}. (preserve blindness)

\Ethan{State compiled protocol and prove soundness that way}

\begin{protocol}{\Cref{proto:BlindBQP} compiled using Mahadev's measurement protocol}
	\label{proto:QPIP0BQP}
	TODO

\end{protocol}

We then apply the recent result parallel repetition to reduce soundness error...

\Ethan{cite both parallel rep papers}

\begin{protocol}{Parallel repetition of}
	\label{proto:repQPIP0BQP}
	Run $n$ copies of \cref{proto:QPIP0BQP} in parallel. Accept if...? TODO some kind of standard procedure here.

\end{protocol}

\subsection{Blind delegation of FBQP}

\Ethan{Need more notation}

Our results for $\BQP$ can also be generalized to $\FBQP$ by applying $2n$ copies of \cref{thm:QPIP0BQP} in parallel.

Let $f\in\FBQP$.

For any input $x\in\set{0, 1}^*$, define $f_i(x)$ to be the $i$-th bit of $f(x)$.

Define the language $L_{i, b}=\set{x:f_i(x)=b}$.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{QPIP0FBQP}
	Input: $x\in\set{0, 1}^n$

	Suppose without loss of generality that the verifier knows $f(x)$ is of length $m=\poly(n)$ \Ethan{Seems like a strong assumption; maybe need to explain how}
	Let $\cL = \set{L_{i, b}: i\in[m], b\in\set{0, 1}}$
	\begin{enumerate}
		\item Run \cref{proto:repQPIP0BQP} for all languages $L\in\cL$ in parallel
		\item If $\exists i$ s.t. $x\in L_{f, i, 0}$ and $x\in L_{i, 1}$ gives the same output, reject.
		\item Otherwise, define $y_i = b$ where $x\in L_{i, b}$. This gives $y\in\set{0,1}^m$
		\item Verifier outputs $y$
	\end{enumerate}
\end{protocol}

\begin{theorem}
	\cref{QPIP0FBQP} has negligible completeness and soundness, and is blind.
\end{theorem}
\begin{prf}
	Completeness is follows by inspection.
	Blindness follows because the executions of \cref{proto:repQPIP0BQP} are blind.

	Soundness... TODO
\end{prf}
