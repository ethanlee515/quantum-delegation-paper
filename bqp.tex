\section{Delegation for BQP}
\label{sec:BlindBQP}

In this section we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

Let $L\in\BQP$, and $x\in\set{0,1}^n$.
We start with an overview of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which was in turn taken from \cite{mf16}.

\begin{protocol}{Verifying yes-instances for $\BQP$}
	\label{proto:BQP}
	We give only a high-level description here.
	\begin{enumerate}
		\item The verifier chooses some tensor product of $X$ and $Z$ measurements $\Lambda$
		\item The prover sends the verifier some state $\rho\in\cB^{\otimes m}$ qubit-by-qubit.
		\item The verifier measures $\rho$ according to $S$
		\item The verifier decides whether to accept based on the measurement results.
	\end{enumerate}
	More details are given later in \cref{AlgGroundStateCheck} where we generalize this protocol for $\SampBQP$.
	\Ethan{TODO clear up details regarding amplification}
\end{protocol}

\cref{proto:BQP} has negligible completeness and soundness. \Ethan{Elaborate or no?}

Now we compile \cref{proto:BQP} using $\mathsf{QHE}$ in order to achieve blindness.
We denote the honest prover's action in \cref{proto:BQP} as $\cF$.

\begin{protocol}{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	Let $d$ be the depth of the circuit corresponding to $\cF$.
	\begin{enumerate}
		\item The verifier chooses $\Lambda$ and computes $\Lambda'$ using \cref{decodeMeasureOrder}
		\item The verifier runs $\mathsf{QHE.Keygen}(1^n, 1^d)$ to get $pk, sk, evk$.
		\item The verifier computes $c=\mathsf{QHE.Enc}_{pk}(x)$
		\item The verifier sends $c$ and $evk$ to the prover
		\item The prover computes $\mathsf{QHE.Eval}(\cF, c)$ and sends it to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext according to $\Lambda'$
		\item The verifier applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to the measurement results
		\item The verifier decides whether to accept based on \cref{proto:BQP}
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and IND-CPA protocol for $\BQP$ with negligible completeness and soundness.

\begin{thm}
	\cref{proto:BlindBQP} preserves the completeness and soundness of \cref{proto:BQP}
\end{thm}
\begin{proof}
	Based on the correctness of $\mathsf{QHE}$, any prover strategy in \cref{proto:BlindBQP} has a corresponding strategy in \cref{proto:BQP}.
\end{proof}

\begin{thm}
	\cref{proto:BlindBQP} is IND-CPA secure.
\end{thm}
\begin{proof}
	The only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.
\end{proof}

Mahadev's protocol compiles $\QPIP_1$ protocols of the form in \cref{proto:BQP} to $\QPIP_0$ but deteriorates soundness.
Note that \cref{proto:BlindBQP} can also be written in the four-step form, so the compiler can also be applied to it.
\cite{parallelrep} says parallel repetition works to recover the soundness guarantees.

So we get...

\begin{rmk}
	Our protocol for $\BQP$ can easily be generalized to $\FBQP$ too in the following way:
	\Ethan{TODO actually need 2 copies per bit now}
\end{rmk}

