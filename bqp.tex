\section{Delegation for BQP}
\label{sec:BlindBQP}

\Ethan{TODO Read other papers and see if I can copy their tones and phrasing}

\Ethan{Note to self: If the original is wordy, just keep it the way it is. Don't try to simplify existing dfns.}

\Ethan{Cut into two subsections, one for BQP and one for FBQP}

In this section we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.

We start with a high-level description of the $\QPIP_1$ scheme from \cite{mahadev_delegation}, which is in turn taken from \cite{mf16}.

This is a one-message $\QPIP_1$ protocol with only $X$ and $Z$ measurement for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a $m$-qubit certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a product measurement $\Lambda$ of $X$ and $Z$s according to certain distribution to apply to $\rho$
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol for $\BQP$ language $L$}
	\label{proto:BQP}
	Input: $x\in\set{0,1}^n$.
	\Ethan{Consider more notation $V_1$, $P_2$... See parallel rep paper. Numbering like this works better for compilers}
	\Ethan{Use terms like ``generate" or arrows; see google docs}
	\begin{enumerate}
		\item On input $x$, the verifier samples $\Lambda$ from a certain distribution $\pi_x$, where $m=\poly(n)$, $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$; each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.
		\item The verifier sends $x$ to the prover.
		\item The prover applies an algorithm $\cF$ \Ethan{Probably P3 or maybe a ``meaningful" name} on $x$ to generate $\rho\in\cB^{\otimes m}$.
		\item The prover sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming qubits of $\rho$ according to $\Lambda$ to get $w$.
		\item The verifier runs some polynomial-time algorithm $\cV$ on input $w$ and outputs either accept or reject.
	\end{enumerate}
\end{protocol}

We compile this protocol using Mahadev's $\mathsf{QHE}$ from \cite{mahadev_qfhe} to obtain a blind 1-message $\QPIP_1$ protocol for $\BQP$, again with only $X$ and $Z$ measurements.
The high level idea is to run \cref{proto:BQP} under $\mathsf{QHE}$.
Namely, the verifier encrypts its original input $x$ and sends $y=\mathsf{QHE.Enc}(x)$ to the prover.
The prover then homomorphically evaluate $\cF$ on $y$ to produce $\sigma=\mathsf{QHE.Enc}(\rho)$ \Ethan{Is this actually ok? $\sigma$ is a ciphertext corresponding to $\rho$, but it wasn't encrypted. In fact it's deteriorated due to homomorphic eval} and send it back to the verifier.

Now the verifier needs to obtain the measurement outcome $w$ from the encrypted state $\sigma$ using qubit-by-qubit $X$ and $Z$ measurements.
This may not be possible in general, but we observe that $\mathsf{QHE}$ allows this. 
Its ciphertexts consists of a Pauli one-time-padded plaintext and classically encrypted Pauli keys.
Pauli one-time-pads commute with $X$ and $Z$ measurements, so the verifier can measure the one-time-padded state as usual then correct the measurement results using the Pauli keys.
We state this observation as the following theorem:

\begin{thm}
	\label{decodeMeasureOrder}
	Let $sk$ be some secret key of $\mathsf{QHE}$.
	Let $n\in\bbN$.
	Let $m\in\bbN$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.
	Let $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$, where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.

	There exists $\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$ where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and polynomial-time algorithm $\widehat{\mathsf{QHE.Dec}}$ such that:
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{proof}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$

	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $u=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $u$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $u$ to get $\Lambda(\rho)$.
\end{proof}

\cref{proto:BQP} has negligible completeness and soundness.
Now we compile it using $\mathsf{QHE}$ in order to also achieve blindness:

\begin{protocol}{Blind Protocol for $\BQP$}
	\label{proto:BlindBQP}
	Let $x\in\set{0,1}^n$.
	Let $d=\poly(n)$ be the depth of the circuit corresponding to $\cF$.
	Take $\pi_{L, x}$, $\cF$, and $\cV$ to be the same as in \cref{proto:BQP}
	\begin{enumerate}
		\item The verifier samples $\Lambda$ from $\pi_{L, x}$
		\item The verifier computes $\Lambda'$ using \cref{decodeMeasureOrder}
		\item The verifier computes $(pk, sk, evk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$.
		\item The verifier computes $y=\mathsf{QHE.Enc}_{pk}(x)$
		\item The verifier sends $y$ and $evk$ to the prover
		\item The prover computes $\sigma=\mathsf{QHE.Eval}(\cF, y)$
		\item The prover sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier measures the incoming ciphertext according to $\Lambda'$, getting $ct$
		\item The verifier applies $\widehat{\mathsf{QHE.Dec}_{sk}}$ to $ct$, getting $w$.
		\item The verifier applies $\cV$ to $w$ and outputs its result.
	\end{enumerate}
\end{protocol}

As we will see in the theorems below, \protoref{BlindBQP} is a $\QPIP_1$, constant round, and IND-CPA protocol for $\BQP$ with negligible completeness and soundness.

\Ethan{Combine the following two theorems}

\begin{thm}
	\cref{proto:BlindBQP} has negligible completeness and soundness.
\end{thm}
\begin{proof}
	The completeness follows by inspection.

	For soundness, suppose the prover sends $\sigma$.

    \Ethan{rewrite the following as a reduction. If exists adversary $P*$ that breaks soundness of this protocol, it breaks the other one...}
    
	The verifier's actions, by \cref{decodeMeasureOrder}, is $\negl(n)$-close to to decoding $\sigma$ to get some $\rho$ then applying $\Lambda$ to get $w$.
	In other words, the verifier's outputs is $\negl(n)$-close to the verifer of \cref{proto:BQP} under the same input and receiving $\rho$ from the prover.
	So the conclusion follows from the negligible soundness of \cref{proto:BQP}.
\end{proof}

\begin{thm}
	\cref{proto:BlindBQP} is blind.
\end{thm}
\begin{proof}
	The only thing the prover sees is $c$ and $evk$, so this follows directly from $\mathsf{QHE}$'s security.
\end{proof}

\Ethan{Use google docs to replace below}

\cite{mahadev_delegation} gives a compiler from $\QPIP_1$ protocols of the form in \cref{proto:BQP} to $\QPIP_0$ but deteriorates soundness.
Note that \cref{proto:BlindBQP} can also be collapsed into the same form \Ethan{Actually specify QPIP1 one-message use only XZ measurements}, so the same compiler can also be applied to it to obtain a $\QPIP_0$ protocol.

We can then use results from \cite{parallelrep} to apply parallel repetition and recover the negligible soundness.

\Ethan{Need more notation}

Our results for $\BQP$ can also be generalized to $\FBQP$ by applying $2n$ copies of \cref{thm:QPIP0BQP} in parallel.

\begin{protocol}{Blind and verifiable $\QPIP_0$ delegation for $\FBQP$}
	\label{QPIP0FBQP}
	Suppose $y\in\set{0,1}^m$ is the output of our $\FBQP$ instance.
	\begin{enumerate}
		\item Apply \cref{thm:QPIP0BQP} to every $y_i=0$ and $y_i=1$ case in parallel, resulting in a total of $2m$ cases.
		\item Output $y$ if for each $i$ precisely one of the $y_i=0$ and $y=i=1$ cases accepts.
	\end{enumerate}
\end{protocol}

\Ethan{TODO prove that \cref{QPIP0FBQP} actually works as expected}
