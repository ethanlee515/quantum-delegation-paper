\section{Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP}

\def\Mah{\mathsf{Mah}}
\nc{\PiMah}{\ensuremath{\Pi_\Mah}}
\nc{\VMah}{\ensuremath{V_\Mah}}
\nc{\PMah}{\ensuremath{P_\Mah}}
\nc{\PMahstar}{\ensuremath{P_\Mah^*}}
\nc{\cVMah}[1]{\ensuremath{\cV_{\Mah,#1}}}
\nc{\cPMah}[1]{\ensuremath{\cP_{\Mah,#1}}}

\def\MF{\mathsf{MF}}
\nc{\PiMF}{\ensuremath{\Pi_\MF}}
\nc{\VMF}{\ensuremath{V_\MF}}
\nc{\PMF}{\ensuremath{P_\MF}}
\nc{\PMFstar}{\ensuremath{P_\MF^*}}
\nc{\cVMF}[1]{\ensuremath{\cV_{\MF,#1}}}
\nc{\cPMF}[1]{\ensuremath{\cP_{\MF,#1}}}

\def\blind{\mathsf{blind}}
\nc{\Piblind}{\ensuremath{\Pi_\blind}}
\nc{\Vblind}{\ensuremath{V_\blind}}
\nc{\Pblind}{\ensuremath{P_\blind}}
\nc{\Pblindstar}{\ensuremath{P_\blind^*}}
\nc{\cVblind}[1]{\ensuremath{\cV_{\blind,#1}}}
\nc{\cPblind}[1]{\ensuremath{\cP_{\blind,#1}}}

\def\bz{\mathsf{blind, 0}}
\nc{\Pibz}{\ensuremath{\Pi_\bz}}
\nc{\Vbz}{\ensuremath{V_\bz}}
\nc{\Pbz}{\ensuremath{P_\bz}}

\def\bzrep{\mathsf{blind, 0, rep}}
\nc{\Pibzrep}{\ensuremath{\Pi_\bzrep}}

\Ethan{TODO Intro this section}

\subsection{Blind Delegation for BQP}
\label{subsec:BlindBQP}

In this subsection we present our constant-round blind delegation protocol for $\BQP$. That is, proving this theorem:
\begin{thm}
	\label{thm:QPIP0BQP}
	There exists a constant-round and blind $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness.
\end{thm}
We'll spend this section construct said protocol piece by piece, starting with the following $\QPIP_1$ protocol for $\BQP$.
\Ethan{Write outline here; highlight key ideas/steps}
We'll later construct a protocol for $\SampBQP$ following the same flow of logic, albeit requiring more careful analysis.
We start with a high-level description of the $\QPIP_1$ scheme $\PiMF$ from \cite{FOCS:Mahadev18a}, which is in turn taken from \cite{mf16}.

This is a one-message $\QPIP_1$ protocol $\PiMF$ with only $X$ and $Z$ measurement for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a measurement basis choice $\Lambda$ according to a certain distribution, and applies it to $\rho$.
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol $\PiMF = (\PMF, \VMF)$ for $\BQP$ language $L$}
	\label{proto:BQP}
	Common input: $x\in\set{0,1}^n$. 
	\begin{enumerate}
		\item The prover generates a $m$-qubit certificate state $\rho\leftarrow\cPMF{1}(x)$ and sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier generates $\Lambda \leftarrow \cVMF{2}(x)$, where $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$;
			each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.
			It applies $\Lambda$ to $\rho$ qubit-by-qubit.
			Let $w \in \set{0,1}^m$ denote the measurement outcome.
			It verifies the measurement outcome and produces a decision $o\leftarrow\cVMF{3}(x, \Lambda, w)$ where $o\in\set{acc, rej}$ and $\cVMF{3}$ is a classical polynomial-time algorithm.
	\end{enumerate}
\end{protocol}
\begin{thm}[from \cite{FOCS:Mahadev18a, mf16}]
    $\PiMF$ has negligible completeness and soundness.
\end{thm}

We compile $\PiMF$ using Mahadev's $\QHE$ from \cite{mahadev_qfhe} to obtain a blind 1-message $\QPIP_1$ protocol $\Piblind$ for $\BQP$, again with only $X$ and $Z$ measurements.
The high level idea is to run $\PiMF$ under $\mathsf{QHE}$.
Namely, the verifier encrypts its original input $x$ and sends $y=\mathsf{QHE.Enc}(x)$ to the prover.
The prover then homomorphically evaluates $\cPMF{3}$ on $ct_x$ to produce $\sigma$ and sends it to the verifier.

Now the verifier needs to obtain the measurement outcome $w$ from the encrypted state $\sigma$ using qubit-by-qubit $X$ and $Z$ measurements.
This may not be possible in general, but we observe that Mahadev's $\mathsf{QHE}$ allows this. 
Its ciphertexts consists of a Pauli one-time-padded plaintext and classically encrypted Pauli keys.
Pauli one-time-pads commute with $X$ and $Z$ measurements, so the verifier can measure the one-time-padded state as usual, then correct the measurement results using the Pauli keys.
Now we state and prove this observation in more precise terms.

\begin{thm}
	\label{decodeMeasureOrder}
	Let $n, L\in\bbN$.
	Let $(pk, sk)\leftarrow\QGen(1^n, 1^L)$
	Let $m=\poly(n)$ be the length of the ciphertexts under $\mathsf{QHE}$ corresponding to plaintexts of length $n$.
	
	There exists efficient classical poly-time algorithms $\cM_\QHE$ and $\widehat{\QDec_{sk}}$ s.t.
	for all $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_n$ where each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement:
	$$\cM_\QHE(\Lambda)=\Lambda'=\Lambda'_1\otimes\ldots\otimes\Lambda'_m$$
	where each $\Lambda_i'$ is a single-qubit $X$ or $Z$ measurement, and
	$$\Lambda\circ\mathsf{QHE.Dec}=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'$$
\end{thm}
\begin{prf}
	This is a proof by construction.
	We require $\Lambda'$ and $\widehat{\mathsf{QHE.Dec}}$ such that $\forall\sigma=(X^xZ^z\rho Z^zX^x, c_{x,z})$,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\widehat{\mathsf{QHE.Dec}}\circ\Lambda'(\sigma)$$
	Clearly,
	$$\Lambda\circ\mathsf{QHE.Dec}(\sigma)=\Lambda(\rho)$$
	
	Let $\Lambda'$ applies $\Lambda$ to the first register, getting $u=\Lambda(X^xZ^z\rho Z^zX^x)$, and applies computational basis measurement to the second register, getting $c_{x, z}$.

	Note that the Pauli one-time pad on $u$ commutes with $X$ and $Z$ measurements.
	So let $\widehat{\mathsf{QHE.Dec}}$ decode $c_{x, z}$ to get $(x, z)$ and undo the one-time pad on $u$ to get $\Lambda(\rho)$.
\end{prf}

Now we state our construction of blind QPIP 1 for BQP by compiling $\PiMF$ using $\QHE$:

\Ethan{TODO Rewrite this}

\begin{protocol}{Blind $\QPIP_1$ 1-message protocol $\Piblind = (\Pblind, \Vblind)$ for $\BQP$ language $L$}
	\label{proto:BlindBQP}
	Verifier's input: $x\in\set{0,1}^n$.
	
	\begin{enumerate}
		\item The verifier generates $(pk, sk, ct_x)\leftarrow\cVblind{1}(x)$ by encrypting $x$, generating
			$(pk, sk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$ where $d$ is the depth of the circuit corresponding to $\cPMF{1}(x)$, then
			$ct_x\leftarrow\mathsf{QHE.Enc}_{pk}(x)$.
			It sends $pk$ and $ct_x$ to the prover.
		\item The prover computes $\sigma\leftarrow\cPblind{1}(pk, ct_x)$ by homomorphically evaluating $\cPMF{1}$ on input $ct_x$, generating $\sigma\leftarrow\QEval_{pk}(\cPMF{1}, ct_x)$.
			It sends $\sigma$ to the verifier qubit-by-qubit.
		\item The verifier generates $\Lambda'\leftarrow\cVblind{2}(x)$ by computing
			$\Lambda\leftarrow\cVMF{2}(x)$,
			$\Lambda'\leftarrow\cM_\QHE(\Lambda)$.
			It measures the incoming state from the verifier, obtaining $ct_w\leftarrow\Lambda'(\sigma)$.
			Lastly, it generates and outputs $o\leftarrow\cVblind{3}(ct_w, sk, x, \Lambda')$ by
			$w\leftarrow\widehat{\mathsf{QHE.Dec}_{sk}}(ct_w)$,
			and $o\leftarrow\cVMF{3}(x, \Lambda, w)$.
	\end{enumerate}
\end{protocol}

\begin{thm}
	\label{thm:BlindBQP}
	$\Piblind$ has negligible completeness and soundness, and is blind.
\end{thm}
\begin{prf}
	The completeness follows by inspection.
	For blindness, the only thing the prover sees is $c$ and $pk$, so it follows directly from $\mathsf{QHE}$'s security.
	
	Now we prove the soundness of $\Piblind$.
	Suppose for the sake of contradiction that there exists some cheating prover $\Pblindstar$ with some noticeable acceptance probability $\varepsilon$.
	Then we can construct a prover $\PMFstar$ violating the soundness guarantees of $\PiMF$ by simulating $(\Vblind(x), \Pblindstar)$ as below:

	We define $\PMFstar$ to first generate
	$(pk, sk)\leftarrow\mathsf{QHE.Keygen}(1^n, 1^d)$
	and
	$ct_x\leftarrow\mathsf{QHE.Enc}_{pk}(x)$
	It then runs $\sigma\leftarrow\cPblind{1}(pk, ct_x)$
	Finally, it decrypts
	$\rho\leftarrow\mathsf{QHE.Dec}_{sk}(\sigma)$
	and sends it to $\VMF$ qubit-by-qubit.

	We now prove that $\PMFstar$ in fact violates the soundness of $\PiMF$.
	Let $\cP_\blind^*$ denote the action $\Pblindstar$ takes to produce $\sigma$ from $ct_x$.
	Observe that the experiments $(\PMFstar, \VMF)(x)$ and $(\Pblindstar, \Vblind(x))$ are identical except for how $w$ is obtained from $\sigma$.
	so by \cref{decodeMeasureOrder} they are equivalent.
	Hence we have $\PMFstar$ with noticeable acceptance probability $\varepsilon$, which is a contradiction.
\end{prf}

\Ethan{Just move \protoref{urmila4} here; that's Urmila's 4 rounds protocol.
Or just move that entire subsection here really.}

\Ethan{TODO Below is copied from google docs; fix phrasing later}

Finally, we prove \cref{thm:QPIP0BQP}.
We use Mahadev's measurement protocol from \cite{FOCS:Mahadev18a} which can compile any $\QPIP_1$ protocol with X, Z measurement and negligible soundness to a $\QPIP_0$ protocol.
The resulting protocol $\Pibz$ is a constant-round $\QPIP_0$ protocol with soundness error $\frac{3}{4} + \negl(n)$ and negligible completeness.

In order to prove blindness, we give a high-level overview of the compiliation results.
\Ethan{Need to discuss about this}

\begin{protocol}{Blind $\QPIP_0$ protocol $\Pibz$ for $BQP$ language $L$}
	\label{proto:QPIP0BQP}
	\Ethan{Sync notations on \PiMah}
	\begin{enumerate}
		\item The verifier generates $(pk, sk, ct_x)\leftarrow\cVblind{1}$,
			$\Lambda'\leftarrow\cVblind{2}(x)$,
			and $(k, td)\leftarrow\cVMah{1}(\Lambda')$.
			It sends $k, pk, ct_x$ to the prover.
		\item The prover generates $\sigma\leftarrow\cPblind{1}(pk, ct_x)$ and
			$(y, st)\leftarrow\cPMah{2}(\sigma)$.
			It sends $y$ to the verifier.
		\item The verifier samples public coin $c\leftarrow\set{0, 1}$ and sends it to the prover.
		\item The prover generates and sends $a\leftarrow\cPMah{3}(c, st)$ to the verifier.
		\item If $c=0$, then the verifier generates and outputs $o\leftarrow\cVMah{T}(k, y, a, sk)$.
			Otherwise, it runs $ct_w\leftarrow\cVMah{H}(k, td, y, a, sk)$,
			then generates and outputs $o\leftarrow\cVblind{3}(ct_w, sk, x, \Lambda')$.
	\end{enumerate}
\end{protocol}

\begin{thm}
	$\Pibz$ has negligible completeness error. Its soundness error is negligibly close to $\frac{3}{4}$.
\end{thm}
\begin{proof}
	Theorem $8.6$ in \cite{FOCS:Mahadev18a} compiles $\PiMF$ into a $\QPIP_0$ in a similar way and obtains this completeness and soundness.
	The proof uses that $\PiMF$ is one-round $\QPIP_1$ with only $X$ and $Z$ measurements on the verifier's side, with negligible completeness and soundness errors.
	$\Piblind$ is two-rounds, but we can treat the verifier's first message as additional classical public inputs, and apply the same logic to the second round.

	For blindness, recall that the prover receives $ct_x, pk, k, c$ from the verifier. Blindness follows by the semantic security of $\QHE$ and the fact that $k$ computationally hides the basis choice $\Lambda'$.
\end{proof}

We use the recent results \cite{parallelrep, alagic2019twomessage} to apply parallel repetition to $\Pibz$ to get $\Pibzrep$ which has negligible soundness.

\begin{thm}[from \cite{parallelrep, alagic2019twomessage}]
	One can repeat $\PiMah$ in parallel to obtain negligible completeness and soundness errors. \Ethan{Something doesn't seem right...}
\end{thm}

\subsection{Blind delegation of FBQP}

\Ethan{TODO PROOFREAD ME}

Our results for $\BQP$ can be generalized to $\FBQP$.

Let $f\in\FBQP$.
For any input $x\in\set{0, 1}^*$, define $f_i(x)$ to be the $i$-th bit of $f(x)$.
For $i\in\bbN, b\in\set{0,1}$, define the language $L_{i, b}=\set{x:f_i(x)=b}$.
Furthermore, define $\cL$ to be the collection of these languages: $\cL = \set{L_{i, b}: i\in[m], b\in\set{0, 1}}$.

\begin{protocol}{Blind and verifiable $\QPIP_0$ protocol $\Pi_{\FBQP}$ for $\FBQP$ language $L$}
	\label{proto:QPIP0FBQP}
	Input: $x\in\set{0, 1}^n$

	Suppose without loss of generality that the verifier knows $f(x)$ is of length $m=\poly(n)$ \Ethan{Seems like a strong assumption; maybe need to explain how?}
	\begin{enumerate}
		\item Run $\Pibzrep$ for all $L\in\cL$ in parallel using input $x$.
		\item The verifier gets outputs $v_{i, b}\in\set{acc, rej}$.
			If $\exists i$ s.t. $v_{i,0}=v_{i,1}$, reject.
			Otherwise, define $y_i = b$ where $v_{i, b}=acc$. This gives $y\in\set{0,1}^m$.
			The verifier accepts and outputs $y$.
	\end{enumerate}
\end{protocol}

\begin{theorem}
	$\Pi_{\FBQP}$ has negligible completeness and soundness, and is blind.
\end{theorem}
\begin{prf}
	Completeness is follows by inspection.
	Blindness follows because the executions of \cref{proto:repQPIP0BQP} are blind.

	By the soundness of $\Pibzrep$, $v_{i, b}=acc$ implies that $x\in L_{i, b}$ with overwhelming probability.
	In other words, $y_i$ is correct with probability $1-\varepsilon_i$ where $\varepsilon_i=\negl(n)$. 
	
	By union bound over all output bits, the soundness of \cref{proto:QPIP0FBQP} is then
	$\sum_{i=1}^m \varepsilon_i$
	which is clearly negligible.
\end{prf}
