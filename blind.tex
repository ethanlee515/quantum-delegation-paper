\def\HE{\mathsf{HE}}
\def\HGen{\mathsf{HE.Keygen}}
\def\HEnc{\mathsf{HE.Enc}}
\def\HEval{\mathsf{HE.Eval}}
\def\HDec{\mathsf{HE.Dec}}

\section{Blindness for $\QPIP_0$ protocols}
\label{sec:BlindBQP2}

In this section we show a relatively simple way to create a blind and constant-round delegation protocol with a classical client for $\BQP$, with negligible soundness and completeness errors.
\Ethan{Talk about the compiler first, and BQP after.}
We start with the protocol from \cite{parallelrep, alagic2019twomessage} which satisfies all our requirements except blindness.
Generally one can obtain blindness by running a protocol under homomorphic encryption. \Ethan{Maybe cite?} In our case, we have a classical client and a quantum server, so we choose the homomorphic encryption from \cite{mahadev_qfhe} that's compatible with this situation.
\Ethan{Talk about FBQP too}

\nc{\ctx}[2]{\ensuremath{{{\widehat{#1}}^{(#2)}}}}

\Ethan{General comment: Make story more interesting. Clearly claim our own contributions.}

\Ethan{Too bottom-up. Need to tell more story.}
We start by summarizing additional properties of Mahadev's $\QHE$ that makes our construction possible.
First, when the plaintext is classical, the encryption can be performed classically.
Moreover, a quantum ciphertext can be measured homomorphically, in which case the measurement outcomes can then be decrypted classically.
Lastly, the encryption is done qubit-by-qubit, so one can split a ciphertext into registers as one would with the corresponding plaintext.

\Ethan{More story here. Talk about stuff like why switch keys.}

We now state our compiler that gives any $\QPIP_0$ protocol blindness.
For notation, when there are many sets of $\QHE$ keys in play at the same time,
we use $\ctx{x}{i}$ to denote $x$ encrypted under $pk_i$.

\begin{protocol}{Compiling $\QPIP_0$ protocol $(P, V)(x)$ into $(\Pblind, \Vblind(x))$}
	Suppose the protocol $(P, V)$ is a $\QPIP_0$ protocol where only the verifier receives outputs, with the following general form:
	
	Public input: $x$
	\begin{enumerate}
		\item $V$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$ and sends $v_1$ to the prover.
		\item $P$ generates $(p_1, st_{P, 1})\leftarrow\cP_1(v_1, x)$ and sends $p_1$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $V$ generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$ and sends $v_t$ to the prover.
			\item $P$ generates $(p_t, st_{P, t})\leftarrow\cP_t(v_t, st_{P, t-1})$ and sends $p_t$ to the verifier.
		\end{enumerate}
		\item $V$ computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
			\Ethan{Prover can get outputs too}
	\end{enumerate}

	Using $\Pi=(P, V)(x)$ from above, we define the protocol $\Piblind=(P, V(x))$ as follows:

	Verifier's input: $x$

	Let $L_t$ be the circuit depth of $\cP_t$.
	Let $\lambda=\abs{x}$.

	\begin{enumerate}
		\item $\Vblind$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$.
			Then it generates $(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^{L_1})$,
			and encrypts $\ctx{x}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v_1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
			It sends $pk_1$, $\ctx{x}{1}$, and $\ctx{v_1}{1}$ to the prover.
		\item $\Pblind$ generates $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\cPblind{1}(\ctx{v_1}{1}, \ctx{x}{1})$
			by evaluating $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\QEval_{pk}(\cP_1, \ctx{v_1}{1}, \ctx{x}{1})$.
			It sends $\ctx{p_1}{1}$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec_{sk_{t-1}}(\ctx{p_{t-1}}{t-1})$,
				then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
				Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^{L_t})$,
				and produces encryptions $\ctx{v_t}{t}\leftarrow\QEnc_{pk_t}(v_t)$ and $\ctx{sk_{t-1}}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
				It sends $pk_t$, $\ctx{v_t}{t}$, and $\ctx{sk_{t-1}}{t}$ to the prover.
			\item $\Pblind$ generates $(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\cPblind{t}(\ctx{v_t}{t}, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1})$
				by first refreshing the $\QHE$ key that encrypts its states by
				first encrypting it under the new key by $\ctx{st_{P, t-1}}{t-1, t}\leftarrow\QEnc_{pk_t}(\ctx{st_{P, t-1}}{t-1}))$,
				then homomorphically decrypting the old encryption under the new key by
				$\ctx{st_{P, t-1}}{t}\leftarrow\QEval_{pk_t}(\QDec, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1, t})$.
				It then applies the next-message function of $\Pi$, generating
				$(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\QEval_{pk_t}(\cP_t, \ctx{v_t}{t}, \ctx{st_{P, t-1}}{t})$.
				It sends $\ctx{p_t}{t}$ back to the verifier.
		\end{enumerate}
		\item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec_{sk_T}(\ctx{p_T}{T})$.
			It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
			\Ethan{Prover can get outputs too}
	\end{enumerate}
\end{protocol}

By the correctness of $\QHE$, the completeness error of $\Piblind$ is negligibly close to that of $\Pi$.
We show the soundness of $\Piblind$ in the following theorem.

\def\Pstar{P^*}
\nc{\cPstar}[1]{\ensuremath{\cP^*_{#1}}}

\begin{theorem}
	For all cheating prover $\Pblindstar$, there exists a cheating prover $\Pstar$ s.t. for all input $x$, the output distributions of $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{theorem}
\begin{proof}
	We define $\Pstar$ so that \Ethan{Fix wording here} on $\cPstar{1}$ it generates
	$(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^{L_1})$, then produces the encryptions
	$\ctx{x}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v_1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
	It then runs $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\cPblind{1}(\ctx{v_1}{1}, \ctx{x}{1})$.
	Finally, it decrypts $p_1\leftarrow\QDec_{sk_1}(\ctx{p_1}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st_{P, 1}}{1}$ and $sk_1$.

	Then, on the rest of the $\cPstar{t}$ rounds, $\Pstar$ generates
	$(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^{L_t})$, and produces ciphertexts
	$\ctx{v_t}{t}\leftarrow\QEnc_{pk_t}(v_t))$ and $\ctx{sk_{t-1}}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
	It then runs $(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\cPblind{t}(\ctx{v_t}{t}, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1})$.
	Finally, it decrypts $p_t\leftarrow\QDec_{sk_t}(\ctx{p_t}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st_{P, t}}{t}$ and $sk_t$.
		
	By construction, the experiments $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{proof}

Finally, we show the blindness of $\Piblind$ through a standard hybrid argument:
\begin{theorem}
	$\Piblind$ is blind.
\end{theorem}
\begin{proof}
	Consider $T+1$ hybrids experiments, from $\Hyb_1$ to $\Hyb_{T+1}$.
	In $\Hyb_i$, we modify $(\Pblind, \Vblind(x))$ s.t.
	for all rounds associated with $\cV{t}$ where $t\geq i$, the verifier replaces the $\ctx{sk_{t-1}}{t}$ in its message with encryption of $0$.
	Then, for all $t$, $\Hyb_{t+1}$ is computationally indistinguishable from $\Hyb_t$ due to the CPA security of $\QHE$ under $pk_t$.
	Since computational indistinguishability is transitive \Ethan{Really? Definitely need to write down some inequalities here...}, $\Hyb_1$ is indistinguishable with $\Hyb_{T+1}$.
	Since $\Hyb_{T+1}$ is precisely $\Piblind$, and $\Hyb_1$ is clearly blind, we can conclude that $\Piblind$ is blind.
\end{proof}
