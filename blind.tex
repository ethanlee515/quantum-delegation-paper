\section{Blindness for $\QPIP_0$ protocols}
\label{sec:BlindBQP2}

\def\HE{\mathsf{HE}}
\def\HGen{\mathsf{HE.Keygen}}
\def\HEnc{\mathsf{HE.Enc}}
\def\HEval{\mathsf{HE.Eval}}
\def\HDec{\mathsf{HE.Dec}}

\def\blind{\mathsf{blind}}
\nc{\Piblind}{\ensuremath{\Pi_\blind}}
\nc{\Vblind}{\ensuremath{V_\blind}}
\nc{\Pblind}{\ensuremath{P_\blind}}
\nc{\Pblindstar}{\ensuremath{P_\blind^*}}
\nc{\cVblind}[1]{\ensuremath{\cV_{\blind,#1}}}
\nc{\cPblind}[1]{\ensuremath{\cP_{\blind,#1}}}
\def\Pstar{P^*}
\nc{\cPstar}[1]{\ensuremath{\cP^*_{#1}}}

In this section we show a relatively simple way to create a blind and constant-round delegation protocol with a classical client for $\BQP$, with negligible soundness and completeness errors.
\Ethan{Talk about the compiler first, and BQP after.}
We start with the protocol from \cite{parallelrep, alagic2019twomessage} which satisfies all our requirements except blindness.
Generally one can obtain blindness by running a protocol under homomorphic encryption. \Ethan{Maybe cite?} In our case, we have a classical client and a quantum server, so we choose the homomorphic encryption from \cite{mahadev_qfhe} that's compatible with this situation.
\Ethan{Talk about FBQP too}

\nc{\ctx}[3]{\ensuremath{{{\widehat{#1}}_{#2}^{(#3)}}}}

\Ethan{General comment: Make story more interesting. Clearly claim our own contributions.}

\Ethan{Too bottom-up. Need to tell more story.}
We start by summarizing additional properties of Mahadev's $\QHE$ that makes our construction possible.
First, when the plaintext is classical, the encryption can be performed classically.
Moreover, a quantum ciphertext can be measured homomorphically, in which case the measurement outcomes can then be decrypted classically.
Lastly, the encryption is done qubit-by-qubit, so one can split a ciphertext into registers as one would with the corresponding plaintext.

\Ethan{More story here. Talk about stuff like why switch keys.}

We now state our compiler that gives any $\QPIP_0$ protocol blindness.
For notation, when there are many sets of $\QHE$ keys in play at the same time,
we use $\ctx{x}{}{i}$ to denote $x$ encrypted under $pk_i$.

We start with a general form of the protocols that we'll compile.

\begin{protocol}{$\QPIP_0$ protocol $\Pi_0=(P, V)(x)$ where only the verifier receives outputs}
	
	Public input: $x$
	\begin{enumerate}
		\item $V$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$ and sends $v_1$ to the prover.
		\item $P$ generates $(p_1, st_{P, 1})\leftarrow\cP_1(v_1, x)$ and sends $p_1$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $V$ generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$ and sends $v_t$ to the prover.
			\item $P$ generates $(p_t, st_{P, t})\leftarrow\cP_t(v_t, st_{P, t-1})$ and sends $p_t$ to the verifier.
		\end{enumerate}
		\item $V$ computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}

\end{protocol}

We compile the above protocol to achieve blindness as follows.

\begin{protocol}{Blind $\QPIP_0$ protocol $\Piblind=(\Pblind, \Vblind(x))$ correponding to $\Pi_0$}

	Verifier's input: $x$

	Let $L=\poly(x)$, $\lambda=\poly(x)$.

	\begin{enumerate}
		\item $\Vblind$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$.
			Then it generates $(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^L)$,
			and encrypts $\ctx{x}{}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v}{1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
			It sends $pk_1$, $\ctx{x}{}{1}$, and $\ctx{v}{1}{1}$ to the prover.
		\item $\Pblind$ generates $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\cPblind{1}(\ctx{v}{1}{1}, \ctx{x}{}{1})$
			by evaluating $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\QEval_{pk}(\cP_1, \ctx{v}{1}{1}, \ctx{x}{}{1})$.
			It sends $\ctx{p}{1}{1}$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec_{sk_{t-1}}(\ctx{p}{t-1}{t-1})$,
				then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
				Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$,
				and produces encryptions $\ctx{v}{t}{t}\leftarrow\QEnc_{pk_t}(v_t)$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
				It sends $pk_t$, $\ctx{v}{t}{t}$, and $\ctx{sk}{t-1}{t}$ to the prover.
			\item $\Pblind$ generates $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t}, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$
				by first switching its encryption key;
				that is, it encrypts its state under the new key by $\ctx{st}{P, t-1}{t-1, t}\leftarrow\QEnc_{pk_t}(\ctx{st}{P, t-1}{t-1}))$,
				then homomorphically decrypts the old encryption by
				$\ctx{st}{P, t-1}{t}\leftarrow\QEval_{pk_t}(\QDec, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1, t})$.
				Then it applies the next-message function of $\Pi$ homomorphically, generating
				$(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\QEval_{pk_t}(\cP_t, \ctx{v}{t}{t}, \ctx{st}{P, t-1}{t})$.
				It sends $\ctx{p}{t}{t}$ back to the verifier.
		\end{enumerate}
		\item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec_{sk_T}(\ctx{p}{T}{T})$.
			It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}
\end{protocol}

By the correctness of $\QHE$, the completeness error of $\Piblind$ is negligibly close to that of $\Pi$.
We show the soundness of $\Piblind$ in the following theorem.

\begin{theorem}
	For all cheating prover $\Pblindstar$, there exists a cheating prover $\Pstar$ s.t. for all input $x$, the output distributions of $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{theorem}
\begin{proof}
	We define $\Pstar$ as follows.
	
	On $\cPstar{1}$ it generates
	$(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^L)$, then produces the encryptions
	$\ctx{x}{}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v}{1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
	It then runs $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\cPblind{1}(\ctx{v}{1}{1}, \ctx{x}{}{1})$.
	Finally, it decrypts $p_1\leftarrow\QDec_{sk_1}(\ctx{p}{1}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st}{P, 1}{1}$ and $sk_1$.

	Then, on the rest of the $\cPstar{t}$ rounds, it generates
	$(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$, and produces ciphertexts
	$\ctx{v}{t}{t}\leftarrow\QEnc_{pk_t}(v_t))$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
	It then runs $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t}, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$.
	Finally, it decrypts $p_t\leftarrow\QDec_{sk_t}(\ctx{p}{t}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st}{P, t}{t}$ and $sk_t$.
		
	By construction, the experiments $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{proof}

Finally, we show the blindness of $\Piblind$ through a standard hybrid argument:
\begin{theorem}
	$\Piblind$ is blind.
\end{theorem}
\begin{proof}
	Consider $T+1$ hybrids experiments, from $\Hyb_1$ to $\Hyb_{T+1}$.
	In $\Hyb_i$, we modify $(\Pblind, \Vblind(x))$ s.t.
	for all rounds associated with $\cV{t}$ where $t\geq i$, the verifier replaces the $\ctx{sk}{t-1}{t}$ in its message with encryption of $0$.
	Then, for all $t$, $\Hyb_{t+1}$ is computationally indistinguishable from $\Hyb_t$ due to the CPA security of $\QHE$ under $pk_t$.
	By applying triangle inequality iteratively\Ethan{Is this enough or do we need equations?}, we obtain that $\Hyb_1$ is indistinguishable with $\Hyb_{T+1}$.
	Since $\Hyb_{T+1}$ is precisely $\Piblind$, and $\Hyb_1$ is clearly blind, we conclude that $\Piblind$ is blind.
\end{proof}
