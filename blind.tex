\section{Achieving Blindness on $\QPIP_0$ protocols}
\label{sec:BlindBQP2}

Here we present our compiler on $\QPIP_0$ protocols that can be used to achieves blindness.
The high level idea is to run the protocol under homomorphic encryption.
A classical version of this compiler appears in \cite{KMThesis}, where it is used to make protocols computationally simulatable.
We have a classical client and a quantum server.
So we choose the quantum homomorphic encryption from \cite{mahadev_qfhe} that's compatible with classical clients.
More precisely, when the corresponding plaintext is classical, encryption and decryption can be performed classically.
Furthermore, we notice that the ciphertexts can be split into registers as with the corresponding plaintext.

A naive approach is to encrypt the initial input,
run the entire protocol homomorphically,
then decode the output at the very end.
However, it is difficult to prove the soundness this way because homomorphic encryption schemes doesn't guarantee circuit privacy;
the server could learn about ther client's coins.
Furthermore, the prover would also be allowed to send invalid ciphertexts...?
\Ethan{Can't we assume all ciphertexts are valid, and ``invalid" ones just decodes to $\bot$?}
So instead we let the verifier decrypt every round.
Then, in order the preserve blindness, the verifier generates a new set of keys for every message it sends to the prover...
Which results in the following protocol.

\Ethan{General comment: Make story more interesting. Clearly claim our own contributions.}

We now state our compiler that gives any $\QPIP_0$ protocol blindness.
For notation, when there are many sets of $\QHE$ keys in play at the same time,
we use $\ctx{x}{}{i}$ to denote $x$ encrypted under $pk_i$.

\begin{protocol}{$\QPIP_0$ protocol $\Pi_0=(P, V)(x)$ where only the verifier receives outputs}
	
	Public input: $x$
	\begin{enumerate}
		\item $V$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$ and sends $v_1$ to the prover.
		\item $P$ generates $(p_1, st_{P, 1})\leftarrow\cP_1(v_1, x)$ and sends $p_1$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $V$ generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$ and sends $v_t$ to the prover.
			\item $P$ generates $(p_t, st_{P, t})\leftarrow\cP_t(v_t, st_{P, t-1})$ and sends $p_t$ to the verifier.
		\end{enumerate}
		\item $V$ computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}

\end{protocol}

We compile the above protocol to achieve blindness as follows.

\begin{protocol}{Blind $\QPIP_0$ protocol $\Piblind=(\Pblind, \Vblind(x))$ correponding to $\Pi_0$}

	Verifier's input: $x$

	Let $L=\poly(x)$, $\lambda=\poly(x)$.

	\begin{enumerate}
		\item $\Vblind$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$.
			Then it generates $(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^L)$,
			and encrypts $\ctx{x}{}{1}\leftarrow\QEnc(pk_1, x)$ and $\ctx{v}{1}{1}\leftarrow\QEnc(pk_1, v_1)$.
			It sends $pk_1$, $\ctx{x}{}{1}$, and $\ctx{v}{1}{1}$ to the prover.
		\item $\Pblind$ generates $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\cPblind{1}(\ctx{v}{1}{1}, \ctx{x}{}{1})$
			by evaluating $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\QEval(pk, \cP_1, \ctx{v}{1}{1}, \ctx{x}{}{1})$.
			It sends $\ctx{p}{1}{1}$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec(sk_{t-1}, \ctx{p}{t-1}{t-1})$,
				then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
				Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$,
				and produces encryptions $\ctx{v}{t}{t}\leftarrow\QEnc(pk_t, v_t)$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc(pk_t, sk_{t-1})$.
				It sends $pk_t$, $\ctx{v}{t}{t}$, and $\ctx{sk}{t-1}{t}$ to the prover.
			\item $\Pblind$ generates $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t}, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$
				by first switching its encryption key;
				that is, it encrypts its state under the new key by $\ctx{st}{P, t-1}{t-1, t}\leftarrow\QEnc(pk_t, \ctx{st}{P, t-1}{t-1}))$,
				then homomorphically decrypts the old encryption by \linebreak
				$$\ctx{st}{P, t-1}{t}\leftarrow\QEval(pk_t, \QDec, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1, t}).$$
				Then it applies the next-message function homomorphically, generating
				$(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\QEval(pk_t, \cP_t, \ctx{v}{t}{t}, \ctx{st}{P, t-1}{t})$.
				It sends $\ctx{p}{t}{t}$ back to the verifier.
		\end{enumerate}
		\item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec(sk_T, \ctx{p}{T}{T})$.
			It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}
\end{protocol}

By the correctness of $\QHE$, the completeness error of $\Piblind$ is negligibly close to that of $\Pi$.
We show the soundness of $\Piblind$ in the following theorem.

\begin{theorem}
	For all cheating prover $\Pblindstar$, there exists a cheating prover $\Pstar$ s.t. for all input $x$, the output distributions of $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{theorem}
\begin{proof}
	We define $\Pstar$ as follows.
	
	On $\cPstar{1}$ it generates
	$(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^L)$, then produces the encryptions
	$\ctx{x}{}{1}\leftarrow\QEnc(pk_1, x)$ and $\ctx{v}{1}{1}\leftarrow\QEnc(pk_1, v_1)$.
	It then runs $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\cPblind{1}(\ctx{v}{1}{1}, \ctx{x}{}{1})$.
	Finally, it decrypts $p_1\leftarrow\QDec(sk_1, \ctx{p}{1}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st}{P, 1}{1}$ and $sk_1$.

	Then, on the rest of the $\cPstar{t}$ rounds, it generates
	$(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$, and produces ciphertexts
	$\ctx{v}{t}{t}\leftarrow\QEnc(pk_t, v_t))$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc(pk_t, sk_{t-1})$.
	It then runs $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t}, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$.
	Finally, it decrypts $p_t\leftarrow\QDec(sk_t, \ctx{p}{t}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st}{P, t}{t}$ and $sk_t$.
		
	By construction, the experiments $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{proof}

Finally, we show the blindness of $\Piblind$ through a standard hybrid argument:
\begin{theorem}
	$\Piblind$ is blind.
\end{theorem}
\begin{proof}
	Consider $T+1$ hybrids experiments, from $\Hyb_1$ to $\Hyb_{T+1}$.
	In $\Hyb_i$, we modify $(\Pblind, \Vblind(x))$ s.t.
	for all rounds associated with $\cV{t}$ where $t\geq i$, the verifier replaces the $\ctx{sk}{t-1}{t}$ in its message with encryption of $0$.
	Then, for all $t$, $\Hyb_{t+1}$ is computationally indistinguishable from $\Hyb_t$ due to the CPA security of $\QHE$ under $pk_t$.
	By applying triangle inequality iteratively\Ethan{Is this enough or do we need equations?}, we obtain that $\Hyb_1$ is indistinguishable with $\Hyb_{T+1}$.
	Since $\Hyb_{T+1}$ is precisely $\Piblind$, and $\Hyb_1$ is clearly blind, we conclude that $\Piblind$ is blind.
\end{proof}

This compiler implies a relatively simple way to create a blind and constant-round delegation protocol with a classical client for $\BQP$, with negligible soundness and completeness errors.
To do so, apply it to the protocol from \cite{parallelrep, alagic2019twomessage}.
Similarly, the compiler can be applied to our $\FBQP$ and $\SampBQP$ protocols \Ethan{TODO name} too.

