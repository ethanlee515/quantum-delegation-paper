\section{Achieving Blindness on $\QPIP_0$ protocols}
\label{sec:BlindBQP2}

Here we present our compiler on $\QPIP_0$ protocols that can be used to achieves blindness.
The high level idea is to run the protocol under homomorphic encryption.
A classical version of this compiler appears in \cite{KMThesis}, where it is used to make protocols computationally simulatable.
We have a classical client and a quantum server.
So we choose the quantum homomorphic encryption from \cite{mahadev_qfhe} that's compatible with classical clients.
More precisely, when the corresponding plaintext is classical, encryption and decryption can be performed classically.
Furthermore, we notice that the ciphertexts can be split into registers as with the corresponding plaintext.

A naive approach is to encrypt the initial input,
run the entire protocol homomorphically,
then decode the output at the very end.
However, it is difficult to prove the soundness this way because homomorphic encryption schemes doesn't guarantee circuit privacy;
the server could learn about ther client's coins.
Furthermore, the prover would also be allowed to send invalid ciphertexts...?
\Ethan{Can't we assume all ciphertexts are valid, and ``invalid" ones just decodes to $\bot$?}
So instead we let the verifier decrypt every round.
Then, in order the preserve blindness, the verifier generates a new set of keys for every message it sends to the prover...
Which results in the following protocol.

\Ethan{General comment: Make story more interesting. Clearly claim our own contributions.}

We now state our compiler that gives any $\QPIP_0$ protocol blindness.
For notation, when there are many sets of $\QHE$ keys in play at the same time,
we use $\ctx{x}{}{i}$ to denote $x$ encrypted under $pk_i$.
We start with a general form of a $\QPIP_0$ protocol that we'll be compiling.

\begin{protocol}{$\QPIP_0$ protocol $\Pi_0=(P, V)(x)$ where only the verifier receives outputs}
	
	Common inputs\footnote{For the sake of simplicity, we omit accuracy parameter $\varepsilon$ where it exists}:
	\begin{itemize}
		\item Security parameter $1^\lambda$ where $\lambda\in\bbN$
		\item Some classical input $x\in\zo^*$ \Ethan{Or should this be $\zo^n$? Or $\zo^{\poly(\lambda)}$?}
	\end{itemize}

	\begin{enumerate}
		\item $V$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(1^\lambda, x)$ and sends $v_1$ to the prover.
		\item $P$ generates $(p_1, st_{P, 1})\leftarrow\cP_1(1^\lambda, v_1, x)$ and sends $p_1$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $V$ generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$ and sends $v_t$ to the prover.
			\item $P$ generates $(p_t, st_{P, t})\leftarrow\cP_t(v_t, st_{P, t-1})$ and sends $p_t$ to the verifier.
		\end{enumerate}
		\item $V$ computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}

\end{protocol}

We compile the above protocol to achieve blindness as follows.

\begin{protocol}{Blind $\QPIP_0$ protocol $\Piblind=(\Pblind, \Vblind(x))$ correponding to $\Pi_0$}
	Inputs:
	\begin{itemize}
		\item Common input: Security parameter $1^\lambda$ where $\lambda\in\bbN$
		\item Verifier's input: $x\in\zo^n$
	\end{itemize}

	Ingrediants:
	\begin{itemize}
		\item Let $L$ be the maximum circuit depth of $\cP_t$.
	\end{itemize}

	\begin{enumerate}
		\item $\Vblind$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(1^\lambda, x)$.
			Then it generates $(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^L)$,
			and encrypts $\ctx{x}{}{1}\leftarrow\QEnc(pk_1, x)$ and $\ctx{v}{1}{1}\leftarrow\QEnc(pk_1, v_1)$.
			It sends $pk_1$, $\ctx{x}{}{1}$, and $\ctx{v}{1}{1}$ to the prover.
		\item $\Pblind$ generates $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\cPblind{1}(1^\lambda, \ctx{v}{1}{1}, \ctx{x}{}{1})$
			by evaluating
			$(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow  \QEval(pk, \cP_1,$ \  $\QEnc(pk_1, 1^\lambda), \ctx{v}{1}{1}, \ctx{x}{}{1})$.
			It sends $\ctx{p}{1}{1}$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec(sk_{t-1}, \ctx{p}{t-1}{t-1})$,
				then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
				Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$,
				and produces encryptions $\ctx{v}{t}{t}\leftarrow\QEnc(pk_t, v_t)$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc(pk_t, sk_{t-1})$.
				It sends $pk_t$, $\ctx{v}{t}{t}$, and $\ctx{sk}{t-1}{t}$ to the prover.
			\item $\Pblind$ generates $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t}, \ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$
				by first switching its encryption key;
				that is, it encrypts its state under the new key by $\ctx{st}{P, t-1}{t-1, t}\leftarrow\QEnc(pk_t, \ctx{st}{P, t-1}{t-1}))$,
				then homomorphically decrypts the old encryption by
				$\ctx{st}{P, t-1}{t}\leftarrow\QEval(pk_t, \QDec,$ \ $\ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1, t})$.
				Then it applies the next-message function homomorphically, generating
				$(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\QEval(pk_t, \cP_t, \ctx{v}{t}{t}, \ctx{st}{P, t-1}{t})$.
				It sends $\ctx{p}{t}{t}$ back to the verifier.
		\end{enumerate}
		\item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec(sk_T, \ctx{p}{T}{T})$.
			It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}
\end{protocol}

By the correctness of $\QHE$, the completeness error of $\Piblind$ is negligibly close to that of $\Pi$.
We show the soundness of $\Piblind$ in the following theorem.

\begin{theorem}
	For all cheating $\BQP$ prover $\Pblindstar$, there exists a cheating $\BQP$ prover $\Pstar$ s.t. for all $\lambda$ and input $x\in\zo^{\poly(\lambda)}$, the output distributions of $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{theorem}
\begin{proof}
	We define $\Pstar$ as follows.
	
	For the first rounds, it generates
	$(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^L)$, then produces the encryptions
	$\ctx{x}{}{1}\leftarrow\QEnc(pk_1, x)$ and $\ctx{v}{1}{1}\leftarrow\QEnc(pk_1, v_1)$.
	It then runs $(\ctx{p}{1}{1}, \ctx{st}{P, 1}{1})\leftarrow\cPblind{1}(1^\lambda, \ctx{v}{1}{1}, \ctx{x}{}{1})$.
	Finally, it decrypts $p_1\leftarrow\QDec(sk_1, \ctx{p}{1}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st}{P, 1}{1}$ and $sk_1$.

	For the other rounds, it generates
	$(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^L)$, and produces ciphertexts
	$\ctx{v}{t}{t}\leftarrow\QEnc(pk_t, v_t))$ and $\ctx{sk}{t-1}{t}\leftarrow\QEnc(pk_t, sk_{t-1})$.
	It then runs $(\ctx{p}{t}{t}, \ctx{st}{P, t}{t})\leftarrow\cPblind{t}(\ctx{v}{t}{t},$ \ $\ctx{sk}{t-1}{t}, \ctx{st}{P, t-1}{t-1})$.
	Finally, it decrypts $p_t\leftarrow\QDec(sk_t, \ctx{p}{t}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st}{P, t}{t}$ and $sk_t$.
		
	By construction, the experiments $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{proof}

Finally, we show the blindness of $\Piblind$ through a standard hybrid argument:
\begin{theorem}
	$\Piblind$ is blind.
\end{theorem}
\begin{proof}
	We show that for all cheating prover $P^*$, $\lambda\in\bbN$, $x\in\zo^n$,
	$P^*$ cannot distinguish $(P^*, \Vblind(x))(\lambda)$ from $(P^*, \Vblind(0^n))(\lambda)$ with noticeable probability in $\lambda$.
	We use a hybrid argument; let $\Hyb_{T+1}^x=(P^*, \Vblind(x))(\lambda)$ and $\Hyb_{T+1}^0=(P^*, \Vblind(0^n))(\lambda)$.
	For $2\leq t<T+1$, define $\Hyb_t^x$ to be the same as $\Hyb_{t+1}^x$,
	except when $\Vblind$ should send $\ctx{v}{t}{t}$ and $\ctx{sk}{t-1}{t}$, it instead sends encryptions of $0$ under $pk_t$.
	We define $\Hyb_1^x$ to be the same as $\Hyb_2^x$ except the verifier sends encryptions of $0$ in place of $\ctx{x}{}{1}$ and $\ctx{v}{1}{1}$.
	We define $\Hyb_t^0$ similarly. Note that $\Hyb_1^x$ and $\Hyb_1^0$ are identical.

	For all $t$, from the perspective of the prover,
	as it receives no information on $sk_t$,
	$\Hyb_{t+1}^x$ is computationally indistinguishable from $\Hyb_t^x$ due to the CPA security of $\QHE$ under $pk_t$.
	By a standard hybrid argument, we observe that $\Hyb_1^x$ is computationally indistinguishable with $\Hyb_{T+1}^x$.
	We use the the same argument for the computational indistinguishability between $\Hyb_1^0$ and $\Hyb_{T+1}^0$.
	We conclude that $P^*$ cannot distinguish between $\Hyb_{T+1}^x$ and $\Hyb_{T+1}^0$,
	therefore $\Piblind$ is blind.
\end{proof}

Our compiler is a straightforward way of achievement blindness with existing $\QPIP_0$ protocols while preserving other runtime properties.
In particular, we now apply it to the delegation protocol for $\BQP$ from \cite{parallelrep, alagic2019twomessage},
as well as our $\SampBQP$ protocol $\PiSamp$ to obtain the following results respectively.

\Ethan{``preserves soundness" needs just a bit more discussion, since all we've proven are two experiments being identical.}

\begin{theorem}
	There exists a blind, constant-round $\QPIP_0$ protocol for $\BQP$ with negligible completeness and soundness errors.
\end{theorem}

\begin{theorem}
	There exists a computationally sound, blind, and constant-round $\QPIP_0$ protocol for $\SampBQP$ with negligible completeness errors.
\end{theorem}
