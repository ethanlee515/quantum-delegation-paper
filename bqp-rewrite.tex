\section{REWRITE - Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP2}

In this section we show that there's a relatively simple way to create a blind and constant-round $\QPIP_0$ delegation protocol. We create our protocol by running the constant-round $\QPIP_0$ protocol from \cite{FOCS:Mahadev18a} under $\QHE$ from \cite{mahadev_qfhe}. This is possible due to certain additional properties of $\QHE$ that facilitates the use of a classical client. Roughly speaking, measuring the ciphertext in standard basis converts the ciphertext into a ciphertext under some certain other classical homomorphic encryption.

\def\HE{\mathsf{HE}}
\def\HGen{\mathsf{HE.Keygen}}
\def\HEnc{\mathsf{HE.Enc}}
\def\HEval{\mathsf{HE.Eval}}
\def\HDec{\mathsf{HE.Dec}}

\nc{\ctx}[2]{\ensuremath{{{#1}^{(#2)}}}}

Due to some properties (TODO) of $\QHE$, we can abuse the notation and write a collection of registers encrypted under $\QHE$ as $(x_1, x_2)'=(x_1', x_2')$ for $\QHE$...
So suppose $f$ outputs a tuple of registers, when it is evaluated homomorphically we can split its output into corresponding encrypted registers too.

\begin{protocol}{Compiling $\QPIP_0$ protocol $(P, V)(x)$ into $(\Pblind, \Vblind(x))$}
	Suppose the protocol $(P, V)$ is a $\QPIP_0$ protocol where only the verifier receives outputs, with the following general form:
	
	Public input: $x$
	\begin{enumerate}
		\item $V$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$ and sends $v_1$ to the prover.
		\item $P$ generates $(p_1, st_{P, 1})\leftarrow\cP_1(v_1, x)$ and sends $p_1$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $V$ generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$ and sends $v_t$ to the prover.
			\item $P$ generates $(p_t, st_{P, t})\leftarrow\cP_t(v_t, st_{P, t-1})$ and sends $p_t$ to the verifier.
		\end{enumerate}
		\item $V$ computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$
	\end{enumerate}

	Using $\Pi=(P, V)(x)$ from above, we define the protocol $\Piblind=(P, V(x))$ as follows:

	Verifier's input: $x$

	Let $L_t$ be the circuit depth of $\cP_t$.
	Let $\lambda=\abs{x}$.

	\begin{enumerate}
		\item $\Vblind$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$.
			Then it generates $(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^{L_1})$,
			and encrypts $\ctx{x}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v_1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
			It sends $pk_1$, $\ctx{x}{1}$, and $\ctx{v_1}{1}$ to the prover.
		\item $\Pblind$ generates $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\cPblind{1}(\ctx{v_1}{1}, \ctx{x}{1})$
			by evaluating $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\QEval_{pk}(\cP_1, \ctx{v_1}{1}, \ctx{x}{1})$.
			It sends $\ctx{p_1}{1}$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec_{sk_{t-1}}(\ctx{p_{t-1}}{t-1})$,
				then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
				Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^{L_t})$,
				and produces encryptions $\ctx{v_t}{t}\leftarrow\QEnc_{pk_t}(v_t)$ and $\ctx{sk_{t-1}}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
				It sends $pk_t$, $\ctx{v_t}{t}$, and $\ctx{sk_{t-1}}{t}$ to the prover.
			\item $\Pblind$ generates $(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\cPblind{t}(\ctx{v_t}{t}, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1})$
				by first refreshing the $\QHE$ key that encrypts its states by
				first encrypting it under the new key by $\ctx{st_{P, t-1}}{t-1, t}\leftarrow\QEnc_{pk_t}(\ctx{st_{P, t-1}}{t-1}))$,
				then homomorphically decrypting the old encryption under the new key by
				$\ctx{st_{P, t-1}}{t}\leftarrow\QEval_{pk_t}(\QDec, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1, t})$.
				It then applies the next-message function of $\Pi$, generating
				$(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\QEval_{pk_t}(\cP_t, \ctx{v_t}{t}, \ctx{st_{P, t-1}}{t})$.
				It sends $\ctx{p_t}{t}$ back to the verifier.
		\end{enumerate}
		\item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec_{sk_T}(\ctx{p_T}{T})$.
			It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
	\end{enumerate}
\end{protocol}

By the correctness of $\QHE$, the completeness error of $\Piblind$ is negligibly close to that of $\Pi$.
We show the soundness of $\Piblind$ in the following theorem.

\def\Pstar{P^*}
\nc{\cPstar}[1]{\ensuremath{\cP^*_{#1}}}

\begin{theorem}
	For all cheating prover $\Pblindstar$, there exists a cheating prover $\Pstar$ s.t. for all input $x$, the output distributions of $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{theorem}
\begin{proof}
	We define $\Pstar$ so that on $\cPstar{1}$ it generates
	$(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^{L_1})$, then produces the encryptions
	$\ctx{x}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v_1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
	It then runs $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\cPblind{1}(\ctx{v_1}{1}, \ctx{x}{1})$.
	Finally, it decrypts $p_1\leftarrow\QDec_{sk_1}(\ctx{p_1}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st_{P, 1}}{1}$ and $sk_1$.
	Then, on the rest of the $\cPstar{t}$ rounds, $\Pstar$ generates
	$(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^{L_t})$, and produces ciphertexts
	$\ctx{v_t}{t}\leftarrow\QEnc_{pk_t}(v_t))$ and $\ctx{sk_{t-1}}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
	It then runs $(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\cPblind{t}(\ctx{v_t}{t}, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1})$.
	Finally, it decrypts $p_t\leftarrow\QDec_{sk_t}(\ctx{p_t}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st_{P, t}}{t}$ and $sk_t$.
		
	By construction, the experiments $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{proof}

Finally, we show the blindness of $\Piblind$ through a standard hybrid argument:
\begin{theorem}
	$\Piblind$ is blind.
\end{theorem}
\begin{proof}
	Consider $T+1$ hybrids experiments, from $\Hyb_1$ to $\Hyb_{T+1}$.
	In $\Hyb_i$, we modify $(\Pblind, \Vblind(x))$ s.t.
	for all rounds associated with $\cV{t}$ where $t\geq i$, the verifier replaces the $\ctx{sk_{t-1}}{t}$ in its message with encryption of $0$.
	Then, for all $t$, $\Hyb_{t+1}$ is computationally indistinguishable from $\Hyb_t$ due to the CPA security of $\QHE$ under $pk_t$.
	Since computational indistinguishability is transitive \Ethan{really?}, $\Hyb_1$ is indistinguishable with $\Hyb_{T+1}$.
	Note that $\Hyb_{T+1}$ is precisely $\Piblind$, and $\Hyb_1$ is clearly blind. So $\Hyb_{T+1}$ is also blind.
\end{proof}
