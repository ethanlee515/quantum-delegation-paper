\def\HE{\mathsf{HE}}
\def\HGen{\mathsf{HE.Keygen}}
\def\HEnc{\mathsf{HE.Enc}}
\def\HEval{\mathsf{HE.Eval}}
\def\HDec{\mathsf{HE.Dec}}

\section{REWRITE - Blind Delegation for BQP and FBQP}
\label{sec:BlindBQP2}

\nc{\ctx}[2]{\ensuremath{{{#1}^{(#2)}}}}

In this section we show a relatively simple way to create a blind and constant-round $\QPIP_0$ delegation protocol for $\BQP$. We create our protocol by running the constant-round $\QPIP_0$ protocol from \cite{FOCS:Mahadev18a} under $\QHE$ from \cite{mahadev_qfhe}.
This is possible due to additional properties of $\QHE$ that facilitates the use of a classical client. Its encryption can be performed classically.
Then, after the homomorphic evaluation, the server could homomorphically measure the ciphertexts and send the results for the classical client to decrypt.
In fact, this approach is powerful enough to give blindness to any $\QPIP_0$ protocol.

We start with a summarization of $\QHE$ and notations.
First, when there are many sets of $\QHE$ keys in play at the same time,
we use $\ctx{x}{i}$ to denote $x$ encrypted under $pk_i$.
Otherwise, we write $x'$ for a ciphertext corresponding to plaintext $x$.
Moreover, the encryption is done on a qubit-by-qubit basis,
so we can write $(x_1, x_2)'=(x_1', x_2')$.

\begin{protocol}{Compiling $\QPIP_0$ protocol $(P, V)(x)$ into $(\Pblind, \Vblind(x))$}
	Suppose the protocol $(P, V)$ is a $\QPIP_0$ protocol where only the verifier receives outputs, with the following general form:
	
	Public input: $x$
	\begin{enumerate}
		\item $V$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$ and sends $v_1$ to the prover.
		\item $P$ generates $(p_1, st_{P, 1})\leftarrow\cP_1(v_1, x)$ and sends $p_1$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $V$ generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$ and sends $v_t$ to the prover.
			\item $P$ generates $(p_t, st_{P, t})\leftarrow\cP_t(v_t, st_{P, t-1})$ and sends $p_t$ to the verifier.
		\end{enumerate}
		\item $V$ computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
			\Ethan{Prover can get outputs too}
	\end{enumerate}

	Using $\Pi=(P, V)(x)$ from above, we define the protocol $\Piblind=(P, V(x))$ as follows:

	Verifier's input: $x$

	Let $L_t$ be the circuit depth of $\cP_t$.
	Let $\lambda=\abs{x}$.

	\begin{enumerate}
		\item $\Vblind$ generates $(v_1, st_{V, 1})\leftarrow\cV_1(x)$.
			Then it generates $(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^{L_1})$,
			and encrypts $\ctx{x}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v_1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
			It sends $pk_1$, $\ctx{x}{1}$, and $\ctx{v_1}{1}$ to the prover.
		\item $\Pblind$ generates $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\cPblind{1}(\ctx{v_1}{1}, \ctx{x}{1})$
			by evaluating $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\QEval_{pk}(\cP_1, \ctx{v_1}{1}, \ctx{x}{1})$.
			It sends $\ctx{p_1}{1}$ to the verifier.
		\item for $t=2,\ldots,T$:
		\begin{enumerate}
			\item $\Vblind$ decrypts the prover's last message by $p_{t-1}\leftarrow\QDec_{sk_{t-1}}(\ctx{p_{t-1}}{t-1})$,
				then generates $(v_t, st_{V, t})\leftarrow\cV_t(p_{t-1}, st_{V, t-1})$.
				Then it generates $(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^{L_t})$,
				and produces encryptions $\ctx{v_t}{t}\leftarrow\QEnc_{pk_t}(v_t)$ and $\ctx{sk_{t-1}}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
				It sends $pk_t$, $\ctx{v_t}{t}$, and $\ctx{sk_{t-1}}{t}$ to the prover.
			\item $\Pblind$ generates $(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\cPblind{t}(\ctx{v_t}{t}, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1})$
				by first refreshing the $\QHE$ key that encrypts its states by
				first encrypting it under the new key by $\ctx{st_{P, t-1}}{t-1, t}\leftarrow\QEnc_{pk_t}(\ctx{st_{P, t-1}}{t-1}))$,
				then homomorphically decrypting the old encryption under the new key by
				$\ctx{st_{P, t-1}}{t}\leftarrow\QEval_{pk_t}(\QDec, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1, t})$.
				It then applies the next-message function of $\Pi$, generating
				$(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\QEval_{pk_t}(\cP_t, \ctx{v_t}{t}, \ctx{st_{P, t-1}}{t})$.
				It sends $\ctx{p_t}{t}$ back to the verifier.
		\end{enumerate}
		\item $\Vblind$ decrypts the prover's final message by $p_T\leftarrow\QDec_{sk_T}(\ctx{p_T}{T})$.
			It then computes its output $o\leftarrow\cV_{out}(p_T, st_{V, T})$.
			\Ethan{Prover can get outputs too}
	\end{enumerate}
\end{protocol}

By the correctness of $\QHE$, the completeness error of $\Piblind$ is negligibly close to that of $\Pi$.
We show the soundness of $\Piblind$ in the following theorem.

\def\Pstar{P^*}
\nc{\cPstar}[1]{\ensuremath{\cP^*_{#1}}}

\begin{theorem}
	For all cheating prover $\Pblindstar$, there exists a cheating prover $\Pstar$ s.t. for all input $x$, the output distributions of $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{theorem}
\begin{proof}
	We define $\Pstar$ so that on $\cPstar{1}$ it generates
	$(pk_1, sk_1)\leftarrow\QGen(1^\lambda, 1^{L_1})$, then produces the encryptions
	$\ctx{x}{1}\leftarrow\QEnc_{pk_1}(x)$ and $\ctx{v_1}{1}\leftarrow\QEnc_{pk_1}(v_1)$.
	It then runs $(\ctx{p_1}{1}, \ctx{st_{P, 1}}{1})\leftarrow\cPblind{1}(\ctx{v_1}{1}, \ctx{x}{1})$.
	Finally, it decrypts $p_1\leftarrow\QDec_{sk_1}(\ctx{p_1}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st_{P, 1}}{1}$ and $sk_1$.
	Then, on the rest of the $\cPstar{t}$ rounds, $\Pstar$ generates
	$(pk_t, sk_t)\leftarrow\QGen(1^\lambda, 1^{L_t})$, and produces ciphertexts
	$\ctx{v_t}{t}\leftarrow\QEnc_{pk_t}(v_t))$ and $\ctx{sk_{t-1}}{t}\leftarrow\QEnc_{pk_t}(sk_{t-1})$.
	It then runs $(\ctx{p_t}{t}, \ctx{st_{P, t}}{t})\leftarrow\cPblind{t}(\ctx{v_t}{t}, \ctx{sk_{t-1}}{t}, \ctx{st_{P, t-1}}{t-1})$.
	Finally, it decrypts $p_t\leftarrow\QDec_{sk_t}(\ctx{p_t}{1})$ and sends it back to the verifier,
	and keeps $\ctx{st_{P, t}}{t}$ and $sk_t$.
		
	By construction, the experiments $(\Pblindstar, \Vblind(x))$ and $(\Pstar, V)(x)$ are identical.
\end{proof}

Finally, we show the blindness of $\Piblind$ through a standard hybrid argument:
\begin{theorem}
	$\Piblind$ is blind.
\end{theorem}
\begin{proof}
	Consider $T+1$ hybrids experiments, from $\Hyb_1$ to $\Hyb_{T+1}$.
	In $\Hyb_i$, we modify $(\Pblind, \Vblind(x))$ s.t.
	for all rounds associated with $\cV{t}$ where $t\geq i$, the verifier replaces the $\ctx{sk_{t-1}}{t}$ in its message with encryption of $0$.
	Then, for all $t$, $\Hyb_{t+1}$ is computationally indistinguishable from $\Hyb_t$ due to the CPA security of $\QHE$ under $pk_t$.
	Since computational indistinguishability is transitive \Ethan{really?}, $\Hyb_1$ is indistinguishable with $\Hyb_{T+1}$.
	Note that $\Hyb_{T+1}$ is precisely $\Piblind$, and $\Hyb_1$ is clearly blind. So $\Hyb_{T+1}$ is also blind.
\end{proof}
