\section{Delegation for FBQP}
\label{sec:FBQP}

\def\MF{\mathsf{MF}}
\nc{\PiMF}{\ensuremath{\Pi_\MF}}
\nc{\VMF}{\ensuremath{V_\MF}}
\nc{\PMF}{\ensuremath{P_\MF}}
\nc{\PMFstar}{\ensuremath{P_\MF^*}}
\nc{\cVMF}[1]{\ensuremath{\cV_{\MF,#1}}}
\nc{\cPMF}[1]{\ensuremath{\cP_{\MF,#1}}}

We start with the one-message $\QPIP_1$ protocol $\PiMF$ given in \cite{mf16} for deciding a $\BQP$ language $L$.
Roughly, on input $x\in\set{0,1}^n$, the prover sends a certificate state $\rho$ to the verifier qubit-by-qubit.
The verifier samples a measurement basis choice $\Lambda$ according to a certain distribution, and applies it to $\rho$.
The verifier then, using the measurement results, decides whether to accept or reject.

\begin{protocol}{1-message $\QPIP_1$ protocol $\PiMF = (\PMF, \VMF)$ for $\BQP$ language $L$}
	\label{proto:BQP}
	Common input: $x\in\set{0,1}^n$. 
	\begin{enumerate}
		\item The prover generates a $m$-qubit certificate state $\rho\leftarrow\cPMF{1}(x)$ and sends $\rho$ to the verifier qubit-by-qubit.
		\item The verifier samples $\Lambda \leftarrow \cVMF{2}(x)$, where $\Lambda=\Lambda_1\otimes\ldots\otimes\Lambda_m$;
			each $\Lambda_i$ is a single-qubit $X$ or $Z$ measurement.
			It then applies $\Lambda$ to $\rho$ qubit-by-qubit, obtaining $w\leftarrow\Lambda(\rho)$.
			Finally, it verifies the measurement outcome and produces a decision $o\leftarrow\cVMF{3}(x, \Lambda, w)$ where $o\in\set{acc, rej}$ and $\cVMF{3}$ is a classical polynomial-time algorithm.
	\end{enumerate}
\end{protocol}
\begin{thm}[from \cite{FOCS:Mahadev18a, mf16}]
    $\PiMF$ has negligible completeness and soundness.
\end{thm}

Here we state our delegation protocol for $\FBQP$.
We do so by breaking an $\FBQP$ instance down into $\BQP$ instances.
Note that our $\BQP$ scheme is one-sided; the prover is allowed to cause the verifier to reject a yes-instance. \Ethan{Explain this better... Write more intuitions. Decision vs function problems; exists vs for all}
As a result, we run two copies of $\PiMF$ for every output bit as below:

\begin{protocol}{$\QPIP_1$ protocol $\Pi_{\FBQP}$ for $f\in\FBQP$}
	\label{proto:QPIP0FBQP}
	Verifier's input: $x\in\set{0, 1}^n$

	Denote the $i$-th bit of $f(x)$ as $f_i(x)$.
	For $i\in\bbN, b\in\set{0,1}$, define the $\BQP$ language $L_{i, b}=\set{s\in\set{0,1}^* : f_i(s)=b}$.
	Let $m=\abs{f(x)}$; we assume without loss of generality that it depends only on $n$ and can be efficiently computed classically.
	\Ethan{Move this assumption to the definition and make a remark there}
	\begin{enumerate}
		\item For all $i\in[m], b\in\set{0, 1}$ in parallel, the verifier and the prover run $\PiMF(x)$ for $L_{i, b}$.
		\item The verifier gets outputs $v_{i, b}\in\set{acc, rej}$.
			If $\exists i$ s.t. $v_{i,0}=v_{i,1}$, reject.
			Otherwise, define $y\in\set{0,1}^m$ s.t. $y_i = b$ where $v_{i, b}=acc$,
			The verifier accepts and outputs $y$.
	\end{enumerate}
\end{protocol}

\begin{theorem}
	$\Pi_{\FBQP}$ has negligible completeness and soundness errors.
\end{theorem}
\begin{prf}
	Completeness follows by inspection.

	By the soundness of $\PiMF$, $v_{i, b}=acc$ implies that $x\in L_{i, b}$ with overwhelming probability.
	In other words, $y_i$ has probability $\varepsilon_i=\negl(n)$ to be incorrect.
	By union bound over all output bits, the soundness of $\Pi_{\FBQP}$ is
	$\sum_{i=1}^m \varepsilon_i=\negl(n)$.
\end{prf}
