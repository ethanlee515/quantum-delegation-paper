\section{Delegation Protocol for Fully Classical Client}

%\hannote{In this section, we modify the construction of \cite{FOCS:Mahadev18a} to show that a $\QPIP_1$ protocol for $\SampBQP$ implies a $\QPIP_0$ for $\SampBQP$.}

% We then extend our scheme for $\QPIP_0$ using results from \cite{FOCS:Mahadev18a}.

In this section, we combine \Cref{QPIP1thm} with results from \cite{FOCS:Mahadev18a} to create a delegation protocol for $\SampBQP$ for fully classical clients. To boost its soundness, we need  polynomially many repetitions, so we use results from \cite{parallelrep} to run polynomially many copies in parallel and get a constant-round protocol.


%Subprotocol for Quantum Measurements
% \subsection{$\QPIP_0$ for BQP?}
% \hannote{Ethan old description before parallel rep.}
% As a warm-up, we  restate the construction in \cite{FOCS:Mahadev18a}, which shows that $\QPIP_1$ protocol for $\BQP$ implies a $\QPIP_0$ for $\BQP$.

% Let $\rho$ be an $n$-qubit state. Let $h$ be an n-bits string called the \emph{basis choice}. That is, $h_i=0$ indicates that the $i$-th qubit of $\rho$ is to be measured in the standard basis, while $i=1$ indicates Hadamard basis measurement instead. Let $D_{\rho, h}$ be the distribution of the corresponding measurement results.



\subsection{Mahadev's measurement protocol}

In her groundbreaking work, Mahadev~\cite{FOCS:Mahadev18a} gives a $\QPIP_0$ protocol for $\BQP$ languages.
The core of this work is a 4-round $\QPIP_0$ protocol $\PiMeasure$ that lets a $\BQP$ machine ``commit a $XZ$ measurement" to a classical machine.
Intuitively, the prover commits to a state $\rho$, while
the verifier chooses a string $h$ that specifies the measurement he wants to make: if $h_i=0$, he wants a $X$ measurement on $i$-th qubit; if $h_i=1$, he wants a $Z$ measurement on $i$-th qubit.
At the end of $\PiMeasure$, the verifier learns a measurement outcome $M_{XZ}(\rho, h)$.
We now describe the interface of $\PiMeasure$ while omitting the implementation details.


\begin{protocol}{Mahadev's measurement protocol $\PiMeasure=(\PMeasure, \VMeasure)$}
\label{proto:urmila4}

\Ethan{Make sure this has the right tone as an intro/interface and isn't confusing to the uninitiated.}

Inputs:
\begin{itemize}
	\item Common input: Security parameter $1^\lambda$ where $\lambda\in\bbN$.
	\item Prover's input: a state $\rho\in\cB^{\otimes n}$ for the verifier to measure.
	\item Verifier's input:
	    the measurement basis choice $h \in \{0,1\}^n$ 
\end{itemize}

Protocol:
\begin{enumerate}
	\item \label{step:measure1} The verifier generates a public and secret key pair $(pk, sk)\leftarrow\cVMeasure{1}(1^\lambda, h)$. It sends $pk$ to the prover.
	\item \label{step:measure2} The prover generates $(y, \sigma)\leftarrow\cPMeasure{2}(pk, \rho)$.
		$y$ is a classical ``commitment", and $\sigma$ is some internal state.
		He sends $y$ to the verifier.
	\item \label{step:measure3} The verifier samples $c\xleftarrow{\$}\zo$ uniformly at random and sends it to the prover. $c=0$ indicates what's called a ``testing round", and $c=1$ indicates a ``Hadamard round".
	\item \label{step:measure4} The prover generates a classical string $a\leftarrow\cPMeasure{4}(pk, c, \sigma)$ and sends it to back to the verifier.
	\item \label{step:output} If it is a testing round ($c=0$), then the verifier generates and outputs $o\leftarrow\cVMeasure{T}(pk, y, a)$, where $o\in\set{\Acc, \Rej}$. \Ethan{Just say it's a test that can acc or rej}
		If it is a Hadamard round ($c=1$), then the verifier generates and outputs $v\leftarrow\cVMeasure{H}(sk, h, y, a)$.
\end{enumerate}
\end{protocol}

The verifier only learns the measurement outcome on a Hadamard round.
The protocol achieves a ``binding" property that gives guarantees against cheating provers.

% \begin{definition}
% With loss of generality,  we can assume that the testing round verification is deterministic. We denote the set of strings $a$ \Ethan{Font makes this $a$ look screwy} accepted by the verifier in the testing round with $(pk,y)$ as $\Acc_{pk,y}$. \hannote{do  i actually use this}
% \end{definition}

\begin{lemma}[binding property of $\PiMeasure$]
\label{lem:urmila-binding}
	Let $\PMeasureStar$ be a $\BQP$ cheating  prover for $\PiMeasure$ and $\lambda$ be the security parameter. Under the QLWE assumption, if $\PMeasureStar$ passes the testing round with probability $1-\negl(\lambda)$, then there exists some $\rho$ so that for all verifier's input $h \in \zo^n$, the verifier's outputs on the Hadamard round is computationally indistinguishable from $M_{XZ}(\rho, h)$.
\iffalse	
	Suppose that for all $\lambda\in\bbN$ and $h\in\zo^*$ \Ethan{or $\zo^n$?},
	$\PMeasureStar$ passes the testing round with probability $1-\negl(\lambda)$.
	Then, under the QLWE assumption, there exists some $\rho$ so that for all $h$,
	the verifier's outputs on the Hadamard round is $\negl(\lambda)$-computationally indistinguishable from $M_{XZ}(\rho, h)$.
\fi
\end{lemma}

We also mention a fact that will be useful later.
\begin{fact}
\label{lem:trivial-4-round-strategy}
   There exist a prover strategy for $\PiMeasure$ that is accepted with probability $1-\negl(\lambda)$ \Ethan{Changed n to lambda here, see what does it affect} in the testing.
\end{fact}

\Ethan{Introduce $(U_{trivial,0},U_{trivial})$ later corresponding to the ``honest" prover}

We now use $\PiMeasure$ to transform our $\QPIP_1$ Protocol for $\SampBQP$, $\PiSamp=(\PSamp, \VSamp)$, to a corresponding $\QPIP_0$ protocol $\PiNaive$.
Recall that in $\PiSamp$ the verifier takes $X$ and $Z$ measurements on the prover's message.
In $\PiNaive$ we let the verifier use $\PiMeasure$ to learn those measurement outcomes instead.

\begin{protocol}{Intermediate $\QPIP_0$ protocol $\PiNaive$ for a $\SampBQP$ problem $(D_x)_{x\in\set{0, 1}^*}$}
	\label{proto:qpip0_naive}

	Inputs:
	\begin{itemize}
		\item Security parameter $1^\lambda$ where $\lambda\in\bbN$
		\item Error parameter $\eps\in(0, 1)$
		\item Classical input $x\in\zo^n$ to the $\SampBQP$ instance
	\end{itemize}

	Protocol:
	\begin{enumerate}
		\item \label{step:naive1} The verifier chooses a $XZ$-measurement $h$ from the distribution specified in \stepref{qpip1-verify} of $\PiSamp$.
		\item \label{step:naive2} The prover prepares $\rho$ by running \stepref{qpip1-state-gen} of $\PiSamp$.
		\item \label{step:urmila-in-naive}
		    The verifier and prover run $(\PMeasure(\rho), \VMeasure(h))(1^\lambda)$. On $\PiMeasure$'s second message, we allow the prover to abort by sending $a=\bot$, which does not benefit cheating provers but is useful for analysis.
		    
			If it's a testing round, the verifier accepts or rejects based on the outcome of $\PiMeasure$.
			If it's a Hadamard round, the verifier obtains $v$.
		\item \label{step:naive-output} If it's a Hadamard round, the verifier finishes the verification step of Protocol~\ref{ProtoQPIP1} by generating and outputting $(d, z)$
			
	\end{enumerate}
\end{protocol}

Note that in $\PiNaive$ the verifier only learns the output in Hadamard round.
So $\PiNaive$ is not a $\QPIP_0$ with good completeness or soundness.
On the other hand, it also has a binding property, which we will use to achieve completeness and soundness in \Cref{sec:qpip0}.

\Ethan{TODO move the following}

\begin{lem}[another triangle inequality for computational distance]\label{lem:computational-triangle}
Let $D_1$, $D_2$ be two distributions such that $D_1=D_3+D_4$ and $D_2=D_5+D_6$, where $D_3$, $D_4$, $D_5$, and $D_6$ are subnormalized distributions.

If
\begin{align}
	D_1\approx_{c,\eps} D_2 \\
	D_4\approx_{c,\eps'} D_6,
\end{align}
then
\begin{align}
	D_3\approx_{c,\eps+\eps'} D_5
\end{align}
\end{lem}
% \begin{align}
%     D_1 &\approx_{q,\eps} D_2 \\
%     D_4 &\approx_{q,\eps'} D_6,
% \end{align}
% then
% \begin{align}
%     D_3 \approx_{q,\eps+\eps'} D_5
% \end{align}
\begin{proof}
% Since
% $$\norm{D_4 - D_6}_q \leq \eps',$$
% there exist


We prove by contradiction. Suppose that
$$D_3\not\approx_{c, \eps+\eps'} D_5,$$
then there exist a quantum circuit $A$ of size $poly(n)$ such that
$$\L\|\Pr[A({D_3})=1]-\Pr[A({D_5})=1]  \R\| > \eps+\eps'.$$
Since $$D_4\approx_{c, \eps'}D_6,$$ we know that
$$\L\|\Pr[A({D_4})=1]-\Pr[A({D_6})=1]  \R\| \leq \eps'.$$
Since $D_1=D_3+D_4$ and $D_2=D_5+D_6$, we have that
$$ \Pr[A({D_1})=1]= \Pr[A({D_3})=1]+ \Pr[A({D_4})=1]$$
$$ \Pr[A({D_2})=1]= \Pr[A({D_5})=1]+ \Pr[A({D_6})=1].$$
So
\begin{align}
    &\L\|\Pr[A({D_1})=1]-\Pr[A({D_2})=1]  \R\| \nn \\
    =&   \L\|\Pr[A({D_3})=1]-\Pr[A({D_5})=1] +\Pr[A({D_4})=1]-\Pr[A({D_6})=1]  \R\| \nn \\
    \geq  &\L\|\Pr[A({D_3})=1]-\Pr[A({D_5})=1]  \R\| - \L\|\Pr[A({D_6})=1]-\Pr[A({D_4})=1]  \R\|  \nn \\
     > &\eps
\end{align}
	This contradicts with the assumption that $D_1\approx_{c,\eps}D_2$.
\end{proof}



\hannote{comp. indistinguish for subnormalized state?}
\hannote{triangle inequality}

\begin{lemma}[binding property of $\PiNaive$]
\label{lem:naive-qpip0-binding}
	Let $\PNaiveStar$ be a cheating $\BQP$ prover for $\PiNaive$ and $\lambda$ be the security parameter.
	Under the QLWE assumption, if conditioned on $\PNaiveStar$ not aborting, $\PNaiveStar$ passes the testing round with probability $1-\negl(\lambda)$,
	\Ethan{Wrong assumption. The ``perfect prover" notion here is generalized and allows giving up.}
	then the verifier's output in the Hadamard round is $(\eps+\negl(\lambda))$-computationally indistinguishable from $(d, z_{ideal})$.
\end{lemma}

\begin{proof}
	\Ethan{TODO this is currently wrong and I'm not sure how to fix it.
	The version before this which had subnormalized states seems strange too.
	The correct proof should involve an alternative prover strategy that ``fixes" the abort case
	by re-running with perfect prover strategy,
	in order to connect the dots with \Cref{lem:urmila-binding}}
	By \Cref{lem:urmila-binding},
	there exist some $\rho$ such that
	$v\approx_{c,\negl(\lambda)}M_{XZ}(\rho,h)$.
	Let $\cVVer$ be the verification operation in \stepref{qpip1-verify} of $\PiSamp$.
	Since $\cVVer$ is efficient, we have
	$(d,z)\approx_{c, \negl(\lambda)}\cVVer(M_{XZ}(\rho, h))$.
	\Ethan{There were some shenanigans involving subnormalized states for which I'm not quite sure what's going on.}
	By \Cref{QPIP1thm}, for all $\rho$, 
	$\cVVer(M_{XZ}(\rho, h))\approx_{c, \eps}(d, z_{ideal})$.
	So we conclude that
	$(d, z)\approx_{c, \eps+\negl(\lambda)}(d, z_{ideal})$.
	
	\Ethan{Original proof below.}
	
	By Lemma~\ref{lem:urmila-binding}, if the prover passes the testing round with probability $1-\negl(n)$, there exist a $\rho$ such that $\norm{z_{commit}- M_{XZ}(\rho,h)}_q \leq \negl(n)$. Note that the prover can choose to abort, so $z_{commit}$ and $\rho$ are subnormalized. Let $Ver$ be the verification operation run by Protocol~\ref{ProtoQPIP1} on the measurement outcome. \hannote{describe better} Since $Ver$ is an efficient process and $Ver(z_{commmit})+p_{abort}(\Rej,\bot)=(d,z_{naive})$, we have that

\begin{equation} \label{eq:z=verM}
    \norm{(d,z_{naive})-(Ver( M_{XZ}(\rho,h))+p_{abort}(\Rej,\bot))}_q \leq \negl(n).
\end{equation}
\hannote{actually true with subnormalize shit?}
 By Theorem~\ref{QPIP1thm}, for all $\rho$,
 \begin{equation}
     \norm{Ver(M_{XZ}(\rho,h))-(d,z_{ideal})} \leq O(\eps).
 \end{equation}
   Combined with Equation~\ref{eq:z=verM} and Lemma~\ref{lem:computational-triangle0}, and note that $\norm{(\Rej,\bot)-(d,z_{ideal})}=0$, we have that
   \begin{equation}
       \norm{(d,z_{naive})-(d,z_{ideal})}_q\leq O(\eps)
   \end{equation}
\end{proof}

\begin{proof}
For every cheating prover $\PNaiveStar$ which aborts, consider an alternative prover $P_{alt}$ which is $\PNaiveStar$ with the following modification: on the second round of $\PiMeasure$, if $\PNaiveStar$ would abort, $P_{alt}$ switch to run the trivial strategy specified by Fact~\ref{fact:perfectly_pass_test} instead. This is possible because the message send by the verifier on the first round is classical, so the prover can recalculate everything.

By \Cref{lem:trivial-4-round-strategy} and the assumption of the lemma, $p_{alt}$ passes the testing round with $(1-\negl(\lambda))$ probability. Therefore by Lemma~\ref{lem:urmila-binding}, there exist a state $\rho_{alt}$ such that 
\begin{align} \label{eq:z-alt-rho}
    z_{commit,alt} \approx_{c,\negl(\lambda)} M_{XZ}(\rho_{alt},h).
\end{align}

Note that $z_{commit,alt} = z_{commit}+z_{trivial}$, where $z_{commit}$ and $z_{trivial}$ are sub-normalized states correspond to whether $p_{alt}$ follows $\PNaiveStar$ or the trivial strategy.

By Fact~\ref{lem:trivial-4-round-strategy} and Lemma~\ref{lem:urmila-binding}, there exist a sub-normalized state $\rho_{trivial}$ such that

\begin{align} \label{eq:z-triv-rho}
    z_{trivial} \approx_{c,\negl(\lambda)} M_{XZ}(\rho_{trivial},h).
\end{align}

By Equation~\ref{eq:z-alt-rho}, Equation~\ref{eq:z-triv-rho}, and Lemma~\ref{lem:computational-triangle}, we have 

\begin{align} \label{eq:z-triv-rho}
    z_{commit} \approx_{c,\negl(\lambda)} M_{XZ}(\rho_{commit},h),
\end{align}

where $\rho_{commit} \defeq \rho_{alt}-\rho_{trivial}$.\hannote{wrong, not a state.} Note that 





\end{proof}


\subsection{$\QPIP_0$ protocol for $\SampBQP$} \label{sec:qpip0}
%Parallel Repetition of the Measurement Subprotocol

\iffalse
The following protocol is a $\QPIP_0$ protocol for $\SampBQP$

$\forall c\in\bbN$ Soundness = $O(T^{-c})$

Given inverse poly p(T), we can parameterize the protocol to have soundness p(T)
\fi

%	\label{ProtoQPIP1}

We now introduce our $\QPIP_0$ protocol $\PiSampZ$ for $\SampBQP$.
It is essentially a $m$-fold parallel repetition of $\PiNaive$.
However, instead of choosing whether to run test or Hadamard round randomly each round,
we run $m-1$ test rounds and only one Hadamard round.
In the description of our protocol below, we expand out the uses of $\PiNaive$ and $\PiMeasure$ in order to introduce notations that we need in our analysis.

\begin{protocol}{$\QPIP_0$ protocol $\PiSampZ$ for $\SampBQP$}
\label{proto:QPIP0samp}

Inputs:
	\begin{itemize}
		\item Security parameter $1^\lambda$ for $\lambda\in\bbN$.
		\item Accuracy paramter $1^{1/\eps}$ for the $\SampBQP$ instance
		\item Input $x\in\zo^{\poly(\lambda)}$ for the $\SampBQP$ instance
	\end{itemize}

Ingrediant: Let $m=O(1/\eps^2)$ be the number of parallel repetitions to run.
    
Protocol:
\begin{enumerate}
	\item The verifier generates $m$ independently copies of basis choices $\vec{h}=(h_1,\ldots,h_m)$ as in \stepref{naive1} of $\PiNaive$.
	\item The prover prepares $\rho^{\otimes m}$; each copy of $\rho$ is prepared as in \stepref{naive2} of $\PiNaive$.
	\item The verifier generates $m$ key pairs for $\PiMeasure$, $\vec{pk}=(pk_1,\ldots,pk_m)$ and $\vec{sk}=(sk_1,\ldots,sk_m)$, as in \stepref{measure1} of $\PiMeasure$.
		It sends $\vec{pk}$ to the prover.
	\item The prover generates $\vec{y}=(y_1,\ldots,y_m)$ and $\sigma$ as in \stepref{measure2} of $\PiMeasure$.
		It sends $\vec{y}$ to the verifier.
	\item The verifier samples $r\xleftarrow{\$}[m]$ which is the copy to run Hadamard round for.
		For $1\leq i\leq m$, if $i\ne r$ then set $c_i\leftarrow 0$, else set $c_i\leftarrow 1$.
		It sends $\vec{c}=(c_1,\ldots,c_m)$ to the prover.
	\item The prover generates $\vec{a}$ as in \stepref{measure4} of $\PiMeasure$, and sends it back to the verifier.
	\item \label{step:multi-testing}
		The verifier computes the outcome for each round as in \stepref{output} of $\PiMeasure$.
		If any of the testing round copies are rejected, the verifier outputs $(\Rej, \bot)$.
		Else, it outputs the result from the Hadamard round copy.
\end{enumerate}
\end{protocol}

\Ethan{TODO Fix proof notations. Like U0, U notations might've been undefined; copy from parallel rep paper if needed}

\begin{theorem}\label{thm:qpip0}
	$\PiSampZ$ is a $\QPIP_0$ protocol for $\SampBQP$ with $\negl(\lambda)$ completeness error and computational soundness. 
\end{theorem}


The intuition behind this theorem is that the we send out $m$ independent copies of the naive $\QPIP_0$ and do testing on randomly chosen $m-1$ copies of them, and do Hadamard round and calculate results from the remaining one copy. Therefore if the prover want to cheat, i.e. send something not binding in the Hadamard round copy, he would be caught with probability $1-1/m$. However, the prover is quantum, so he might create quantum correlations that let him cheat with probability more than $1/m$. To prove that such kind of cheating is impossible, we use the following partition lemma from \cite{parallelrep}, which intuitively says that there exist efficient projectors $G_{0,i}$ and $G_{1,i}$ which splits a quantum state in the prover's   internal space into a part that is rejected with high probability in the testing round of $i$-th copy and a part that is accepted with high probability.  $G_{0,i}$ and $G_{1,i}$ need to be efficient because $\PiMeasure$ only gives computational indistinguishability. Once we have $G_{0,i}$ and $G_{1,i}$, we can split up the prover's internal state $\ket{\psi}$ like conditional probabilistic events. For example, $G_{0,3} G_{1,5} \ket{\psi}$ corresponds to the events of passing the testing round on fifth copy then fails the the testing round on the third copy. We split the state sub-normalized states corresponding to the prover cheating on different copies and show that the sum of probabilities corresponding to bad states can't be more than $1/m$. {The actual proof is more complicated than this sketch because the $G$'s don't commute with each other, so we need to handle the splitting carefully.}

%Let $S_m$ be sets of $\{c\}$ such that only one of the $c_i=1$.
\begin{lemma}[partition lemma; revision of Lemma 3.5 of \cite{parallelrep}\footnote{$G_{0}$ and $G_{1}$ of this version are created from doing $G$ of \cite{parallelrep} and post-select on the $th$ register being $0$ or $1$ then discard $ph,th,in$. Property~\ref{property:partition-err} corresponds to Property~1. Property~\ref{property:partition-testing} corresponds to Property~4, with $2^{m-1}$ changes to $m-1$ because we only have $m$ possible choices of $\{c\}$. Property~\ref{property:partition-binding} corresponds to Property~5. Property~\ref{property-partition-norm-sum} comes from the fact that $G_0$ and $G_1$ are post-selections of orthogonal results of the same $G$.}]\label{lem:partition2}
Let $\lambda$ be the security parameter and  $\eps$ be the accuracy parameter. Let $(U_0,U)$ be a prover's strategy in a $m$-fold parallel repetition of $\PiMeasure$, where $U_0$ is how the prover generates $\vec{y}$ on the second message, and $U$ is how the prover generates $\vec{a}$ on the fourth message. Denote the string $0^{i-1}10^{m-i} \in \zo^m $ as $e_i$, which corresponds to Hadamard round on the $i$-th copy and testing round on all others. Let $\gamma_0 \in[0,1]$, and $T\in \mathbb{N}$ such that $\gamma_0=\poly(\eps)$ and $T=1/\poly(\eps)$. \Ethan{These $n$ probably should be $\lambda$}

 For all $i\in[m]$, $\gamma \in \L\{\frac{\gamma_0}{T},\frac{2\gamma_0}{T},\dots,\frac{T\gamma_0}{T}\R\}$, there exist two efficient quantum circuit $G_{0,i,\gamma}$ and $G_{1,i,\gamma}$ such that for all (possibly sub-normalized) $\poly(\lambda)$-qubits quantum state $\ket{\psi}_{\regX,\regZ}$,  

\begin{align}
    G_{0,i,\gamma}\ket{\psi}_{\regX,\regZ} \defeq& \ket{\psi_{0,i,\gamma}}_{\regX,\regZ} \\ G_{1,i,\gamma}\ket{\psi}_{\regX,\regZ} \defeq& \ket{\psi_{1,i,\gamma}}_{\regX,\regZ}  \\
    \ket{\psi}_{\regX,\regZ} =&   \ket{\psi_{0,i,\gamma}}_{\regX,\regZ}+ \ket{\psi_{1,i,\gamma}}_{\regX,\regZ}+\ket{\psi_{err,i,\gamma}}_{\regX,\regZ}
\end{align}

% $$ \ket{\psi}_{\regX,\regZ} =  G_{0,i,\gamma}\ket{\psi}_{\regX,\regZ}+ G_{1,i,\gamma}\ket{\psi}_{\regX,\regZ}+\ket{\psi_{err}}_{\regX,\regZ},$$

 

 
  Note that $G_{0,i,\gamma}$ and $G_{1,i,\gamma}$ has failure probabilities, and this is reflected by the fact that $\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}$ and $\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}$ are  sub-normalized. $G_{0,i,\gamma}$ and $G_{1,i,\gamma}$ depend on $(U_0,U)$ and $\vec{pk},\vec{y}$. 
 


Furthermore, the following properties are satisfied for all $i\in[m]$.
%
\begin{enumerate}
    \item \label{property:partition-err}  $$\E_{\gamma}\|\ket{\psi_{err,i,\gamma}}_{\regX,\regZ}\|^2 \leq \frac{6}{T}+\negl(\lambda),$$
    
    where the averaged is over uniformly sampled $\gamma$. This also implies
    \begin{align}
        \E_{\gamma}\|\ket{\psi_{err,i,\gamma}}_{\regX,\regZ}\| \leq \sqrt{\frac{6}{T}}+\negl(\lambda)
    \end{align}
by Cauchy's inequality.
    
        \item \label{property:partition-testing}
For all $\vec{pk}$, $\vec{y}$, fixed $\gamma$, and  $j\neq i$, we have 
 
%      \begin{align*}
%  \Pr\left[M_{\regX_i}\circ U\frac{\ket{\{c\}}_{\regC}\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_0}_{\regX,\regZ}\|}\in \Acc_{pk_i,y_i}\right]\leq (m-1)\gamma+\negl(\secpar).
%  \end{align*}

%  Define
%  $$\ket{\widetilde{\psi_{0,i,\gamma}}}\defeq U\frac{\ket{\{c\}}_{\regC}\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_0}_{\regX,\regZ}\|}.$$
%  We have
%  \begin{align}
%      \vev{\widetilde{\psi_{0,i,\gamma}}|P_{i,pk_i,y_i,acc}|\widetilde{\psi_{0,i,\gamma}}} \leq (m-1)\gamma+\negl(\secpar),
%  \end{align}
 \begin{align}
    \norm{ P_{i,pk_i,y_i,acc} \circ U\frac{\ket{e_j}_{\regC}\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_0}_{\regX,\regZ}\|}}^2 \leq (m-1)\gamma_0+\negl(\lambda),
 \end{align}
 
 
where $P_{i,pk_i,y_i,acc}$ are projector to the states that $i$-th testing round accepts with $pk_i,y_i$, including the last measurement the prover did before sending $\{a\}$.  This means that $\ket{\psi_{0,i,\gamma}}$ is rejected by $i$-th testing round with high probability.


    \item \label{property:partition-binding}
    
    % $\{c\}\in S_m$ such that $c_i = 0$
For all $\vec{pk}$, $\vec{y}$, fixed $\gamma$, and $j\neq i$, there exists an efficient quantum algorithm $\ext_i$ such that 

\begin{align}
     \norm{P_{i,pk_i,y_i,acc} \circ \ext_i\left(\frac{\ket{e_j}_{\regC}\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_1}_{\regX,\regZ}\|}\right)}^2 =1-\negl(\lambda).
\end{align}

% \begin{align*}  
%   \Pr\left[M_{\regX_i}\circ \ext_i\left(\frac{\ket{\{c\}}_{\regC}\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_1}_{\regX,\regZ}\|}\right)\in \Acc_{pk_i,y_i}\right]=1-\negl(\secpar).
%   \end{align*}
This will imply that    $\ket{\psi_{1,i,\gamma}}$ is binding to $i$-th Hadamard round.

\item \label{property-partition-norm-sum}
  For all $\gamma$, 
  \begin{align}
    \norm{\ket{\psi_{0,i,\gamma}}}^2+ \norm{\ket{\psi_{1,i,\gamma}}}^2 \leq  \norm{\ket{\psi}}^2 
\end{align}

  
% \item \hannote{added by me..not needed?}

% $$\vev{\psi_{0,i,\gamma}|\psi_{1,i,\gamma}} = \negl(n)$$
 


\end{enumerate}
\end{lemma}







% \begin{proof}
% Step~\ref{step:sum-ob}: 
% \begin{align}
%   ( G_{0,i,\gamma}+G_{1,i,\gamma}) \ket{\psi}_{\regX,\regZ}
%   &= \ket{\psi_{0,i,\gamma}}_{\regX,\regZ}+\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}
% \end{align}
% \end{proof}

We also need the following technical lemma.
\begin{lemma}\label{lem:samp-tech}
For any state $\ket{\psi}$,  $\ket{\phi}$ and projectors $\{P_z\}$ such that $\sum_z P_z \leq Id$ and $P_z P_{z'} =0 $ for all $z\neq z'$, we have
$$  \sum_z |\vev{\psi|P_z|\phi}| \leq \norm{\psi}\norm{\phi} $$
\end{lemma}
\begin{proof}
\begin{align}
    \sum_z |\vev{\psi|P_z|\phi}| =&\sum_z|\vev{\psi|P_zP_z|\phi}| \nn \\
    \leq& \sum_z \norm{\bra{\psi}P_z} \norm{ P_z\ket{\phi}} \nn \\
    \leq&  \sqrt{\sum_z \norm{P_z\ket{\psi}}^2} \sqrt{\sum_z\norm{P_z\ket{\phi}}^2} \nn \\
    \leq& \sqrt{\norm{\sum_z P_z\ket{\psi}}^2 } \sqrt{\norm{\sum_z P_z\ket{\phi}}^2 } \nn \\
    \leq & \norm{\ket{\psi}}\norm{\ket{\phi}},
\end{align}
where we used Cauchy's inequality on the second and third line and $P_z P_{z'} =0 $ on the fourth line.
\end{proof}

Now we are ready to prove Theorem~\ref{thm:qpip0}
\begin{proof}

\Ethan{This proof currently only shows $O(\eps)$ accuracy, which doesn't perfectly match up with the definition. Hopefully doesn't matter way too much though?}

Completeness is trivial.


For soundness, We begin by considering the state $\ket{\psi}$ the prover in $\PiSampZ$ holds before he receives $\vec{c}$. We denote the corresponding Hilbert space as $H_{\regX,\regZ}$.

For all $k\leq m$, $d\in \zo^k$, and $\ket{\psi} \in H_{\regX,\regZ}$, define

$$\ket{\psi_{d,\gamma}}\defeq G_{d_k,k,\gamma}G_{d_{k-1},k-1,\gamma}\cdots G_{d_2,2,\gamma} G_{d_1,1,\gamma} \ket{\psi}$$

\Ethan{ew.}

By Lemma~\ref{lem:partition2}, we have  

\begin{align} \label{eq:partition-string}
    \ket{\psi} =& \ket{\psi_{0,\gamma}}+\ket{\psi_{1,\gamma}}+\ket{\psi_{err,1,\gamma}} \nn \\
    =& \ket{\psi_{0,\gamma}}+\ket{\psi_{10,\gamma}}+\ket{\psi_{11,\gamma}}+\ket{\psi_{err,1,\gamma}}+\ket{\psi_{err,2,\gamma}} \nn \\
    =& \ket{\psi_{0,\gamma}}+\ket{\psi_{10,\gamma}}+\ket{\psi_{110,\gamma}}+\cdots+\ket{\psi_{1^{m-1}0,\gamma}}+\ket{\psi_{1^{m-1}1,\gamma}} \nn \\
    &+\ket{\psi_{err,1,\gamma}}+\ket{\psi_{err,2,\gamma}}+\cdots+\ket{\psi_{err,m,\gamma}}, 
\end{align}

where we abuse the notation and use $\ket{\psi_{err,i,\gamma}}$ to denote the error state we get from decomposing $\ket{\psi_{1^{i-1},\gamma}}$. %\hannote{Note that the prover's state is actually a mixed state. In particular, $\ket{\psi}$ depends on $pk$ and we are considering the mixed state averaged over verifier's choice of $pk$.}

By Property~\ref{property-partition-norm-sum} of Lemma~\ref{lem:partition2}, we have
\begin{align} \label{eq:bad-term-sum}
    \norm{\ket{\psi}}^2 \geq& \norm{\ket{\psi_{0,\gamma}}}^2+\norm{\ket{\psi_{1,\gamma}}}^2 \nn \\
    \geq& \norm{\ket{\psi_{0,\gamma}}}^2+
    \norm{\ket{\psi_{10,\gamma}}}^2+ \norm{\ket{\psi_{11,\gamma}}}^2 \nn \\
    \geq& \norm{\ket{\psi_{0,\gamma}}}^2+
    \norm{\ket{\psi_{10,\gamma}}}^2+ \norm{\ket{\psi_{110,\gamma}}}^2 +\cdots  \nn \\
    &+ \norm{\ket{\psi_{1^{m-1}0,\gamma}}}^2+ \norm{\ket{\psi_{1^{m-1}1,\gamma}}}^2
\end{align}

Denote the projector in $H_{\regX,\regZ}$ corresponding to outputting string $z$ when doing Hadamard on $i$-th copy as

$$P_{acc,i,z}.$$
Note that $P_{acc,i,z}$ also depends on $\vec{pk}, \vec{y}$, and $(sk_i, h_i)$ since it includes the measurement the prover did before sending $a$,  verifier's checking on $(m-1)$ copies of testing rounds, and  the verifier's final computation from $(sk_i,h_i,y_i,a_i)$.

Since the verifier only accepts if all $(m-1)$ copies of testing rounds accepts, for all $j\neq i$,

$$P_{acc,i,z}=P_{acc,i,z}P_{j,pk_j,y_j,acc}.$$

And therefore by Property~\ref{property:partition-testing} of Lemma~\ref{lem:partition2}, we have that for all $j <i-1$   %\hannote{problem with $e_j$ or $e_i$}

\begin{align} \label{eq:rejected-d}
    \norm{P_{acc,i,z} U \ket{e_i, \psi_{1^j0,\gamma}}}^2
    =& \norm{P_{acc,i,z}P_{j,pk_j,y_j,acc} U \ket{e_i}\, G_{0,j+1,\gamma}\ket{\psi_{1^j,\gamma}}  }^2 \nn \\
    \leq& \norm{P_{j,pk_j,y_j,acc} U \ket{e_i}\, G_{0,j+1,\gamma}\ket{\psi_{1^j,\gamma}}  }^2 \nn \\
    \leq& (m-1)\gamma_0+\negl(n) 
\end{align}


Denote the string $0^{i-1}10^{m-i} \in \zo^m $ as $e_i$. The output string corresponding to $\ket{\psi} \in H_{\regX,\regZ}$ when $c=e_i$ is then 




$$z_i\defeq \E_{pk,y} \sum_z \proj{z} \cdot \vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi},$$
where $\ket{e_i,\psi}=\ket{e_i}_\regC\ket{\psi}_{\regX,\regZ}$ and $U$ is the unitary the prover applies on the last round. Note that we have averaged over $\vec{pk}, \vec{y}$ where as previously everything has fixed $\vec{pk}$ and $\vec{y}$. 

Since $\vec{c}$ is drawn  from $e_i$ with uniformly random $i\in [m]$, we have 
$$ z=\frac{1}{m} \sum_i z_i= \frac{1}{m} \sum_i \sum_z \proj{z} \cdot \vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi},$$ 
	where we represent the random variable $z$ as a real non-negative diagonal matrix, with the matrix entries begin probabilities. Note that $z$ is ``sub-normalized", i.e. $\tr (z)= \text{probability of getting accepted} \leq 1$.






Define 

\begin{align}
    z_{good,i}=\E_\gamma \sum_z \proj{z} \cdot \vev{e_i,\psi_{1^{i-1}1,\gamma}|U^\dag P_{acc,i,z} U|e_i,\psi_{1^{i-1}1,\gamma}}
\end{align}

Splitting $\ket{\psi}$ with Equation~\ref{eq:partition-string}, 
%\hannote{gamma..}

\begin{align}
    \ket{\psi}=& \L. \ket{\psi_{0,\gamma}}+\ket{\psi_{10,\gamma}}+\ket{\psi_{110,\gamma}}+\cdots+\ket{\psi_{1^{i-1}0,\gamma}}+
    \ket{\psi_{1^{i-1}1,\gamma}} \R. \nn \\
     +& \L.\ket{\psi_{err,1,\gamma}}+\ket{\psi_{err,2,\gamma}}+\cdots+\ket{\psi_{err,i,\gamma}}\R. \nn \\
     =& \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} +\ket{\psi_{1^i,\gamma}} +\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}
\end{align}


we have 

\begin{align}
    z_i =& \sum_z \proj{z} \cdot \vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi} \nn \\
    =& \sum_z \proj{z} \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}} +\bra{\psi_{1^i,\gamma}} +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} \R]U^\dag  P_{acc,i,z} U\nn \\
    &\L[ \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} +\ket{\psi_{1^i,\gamma}} +\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}\R]  \nn \\
    =& \E_\gamma \sum_z \proj{z} \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}} +\bra{\psi_{1^i,\gamma}} +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} \R]U^\dag  P_{acc,i,z} U\nn \\
    &\L[ \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} +\ket{\psi_{1^i,\gamma}} +\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}\R]  \nn \\
    =& z_{good,i}+ \E_\gamma \sum_z \proj{z} \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U   \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}+
    \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}}  \R. \nn \\
      +&  \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \nn \\
    +& \sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U  \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} 
    +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \nn \\
    +&\L.\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \R] , \nn     
    %=& z_{good,i} +(\text{terms with } \psi_{1^j0},\, j\neq i ) + (\text{terms with } \psi_{1^{i-1}0}) +(\text{terms with }err ) 
\end{align}

%  U^\dag  P_{acc,i,z}U

% \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} 
% \ket{\psi_{1^i,\gamma}} 
% \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}  

 where we omitted writing out $e_i$ starting the second line. We have
\begin{align} \label{eq:zi-zgoodi}
    &\tr|z_i-z_{good,i}|   \nn \\
    \leq&  \sum_z  \L| \E_\gamma \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U   \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}+
    \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}}  \R. \R. \nn \\
      +&  \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \nn \\
    +& \sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U  \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} 
    +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \nn \\
    +&\L.\L.\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \R]\R| \nn \\  %%%%%%%%%%%
    \leq&  \sum_z   \E_\gamma \L[\sum_{k=0}^{i-1} \sum_{j=0}^{i-1} \L| \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U    \ket{\psi_{1^j0,\gamma}} \R|+
    2 \sum_{k=0}^{i-1} \L|\bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \R|  \R.  \nn \\
      +&  2 \sum_{k=0}^{i-1}\sum_{j=1}^{i}\L| \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U\ket{\psi_{err,j,\gamma}}\R|    
    +2 \sum_{j=1}^{i}\L|\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{err,j,\gamma}}\R| \nn \\
    +&\L. \sum_{k=1}^{i}\sum_{j=1}^{i}\L| \bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{err,j,\gamma}}\R| \R] \nn \\ %%%%%%%%%
      \leq&  \sum_z   \L[\sum_{k=0}^{i-1} \sum_{j=0}^{i-1} \L| \bra{e_i,\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U    \ket{e_i,\psi_{1^j0,\gamma}} \R|+
    2 \sum_{k=0}^{i-1} \L|\bra{e_i,\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{e_i,\psi_{1^i,\gamma}} \R|  \R]    +O\L(\frac{m^2}{\sqrt T}\R)\nn \\ %%%%%%%%%
    \leq&  \sum_z   \L[\L| \bra{\psi_{1^{i-1}0,\gamma}}U^\dag  P_{acc,i,z}U    \ket{\psi_{1^{i-1}0,\gamma}} \R|+
    2  \L|\bra{\psi_{1^{i-1}0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \R|  \R]    \nn \\ +&O\L(\frac{m^2}{\sqrt T}+m^2{(m-1)\gamma_0}+m\sqrt{(m-1)\gamma_0}\R)\nn \\ %%%%%%%%% 
    \leq& \norm{\ket{\psi_{1^{i-1}0,\gamma}}}^2+ 2\norm{\ket{\psi_{1^{i-1}0,\gamma}}}+O\L(\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R),
\end{align}
where on the second inequality we used triangle inequality, on the third inequality we used  Lemma~\ref{lem:samp-tech} and property~\ref{property:partition-err} of Lemma~\ref{lem:partition2}, on the fourth inequality we used Lemma~\ref{lem:samp-tech} and Equation~\ref{eq:rejected-d}, and on the last inequality we used Lemma~\ref{lem:samp-tech}. Once again, we omit $e_i$ when it is not relevant. 






% \begin{align}
%     &\vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi} \nn \\
%     =& \bra{e_i, \psi_{1^{i-1}1,\gamma}} U^\dag P_{acc,i,z} U \ket{e_i\psi_{1^{i-1}1,\gamma}} +\hannote{poly terms?}+ \negl(n)
% \end{align}

Now we try to  put together all $i\in [m]$. Define
$$z_{good}\defeq \frac{1}{m}\sum_i z_{good,i}.$$

We have 
\begin{align} \label{eq:z-z-good}
    \tr|z-z_{good}| =& \tr\L|\frac{1}{m}\sum_i (z_i-z_{good,i})\R| \nn \\
    \leq&  \frac{1}{m}\sum_i\tr| (z_i-z_{good,i})| \nn \\
    \leq&  \frac{1}{m}\sum_i\L[\norm{\ket{\psi_{1^{i-1}0,\gamma}}}^2+ 2\norm{\ket{\psi_{1^{i-1}0,\gamma}}}+O\L(\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R)\R] \nn \\%%%%%%%%
    \leq&  \frac{1}{m}+ 2\frac{1}{\sqrt m}+O\L(\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R) \nn \\ %%%%%
    =&O\L( \frac{1}{\sqrt m}+\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R)
\end{align}

where we used triangle inequality on the second line, Equation~\ref{eq:zi-zgoodi} on the third line, Equation~\ref{eq:bad-term-sum} and Cauchy's inequality on the fourth line.





We now proceeds to prove that $z_{good}$ is close to the ideal distribution. 

For every $i\in [m]$ and every prover strategy $(U_0,U)$ for Protocol~\ref{proto:QPIP0samp}, consider the following composite strategy of the prover for the naive $\QPIP_0$ Protocol, Protocol~\ref{proto:qpip0_naive}. Note that the prover only interact with the verifier in Step~\ref{step:urmila-in-naive} of Protocol~\ref{proto:qpip0_naive} where Protocol~\ref{proto:urmila4} is run, so we describe the prover's action in turns of the four rounds of communication in Protocol~\ref{proto:urmila4}.

The prover tries to run $U_0$ by taking the verifier's input as $i$-th copy of Protocol~\ref{proto:urmila4} in Protocol~\ref{proto:QPIP0samp} and simulating other $m-1$ copies by himself. The prover then picks a uniformly random $\gamma$ and  tries to generate $\ket{\psi_{1^{i-1}1,\gamma}}$ by applying $G_{i,1,\gamma}G_{i-1,1,\gamma} \cdots G_{2,1,\gamma}G_{1,1,\gamma}$. If the prover fails to generate $\ket{\psi_{1^{i-1}1,\gamma}}$, he throws out everything and run $U_{trivial,0}$ described  in  Lemma~\ref{lem:trivial-4-round-strategy} instead. This is possible because all the inputs are classical. On the fourth round, there are four possibilities depending on $c$ and whether the prover generated $\ket{\psi_{1^{i-1}1,\gamma}}$. If $c=0$ and the prover generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he reply with the $i$-th register of $\ext_i\left(\frac{\ket{e_j}_{\regC}\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_1}_{\regX,\regZ}\|}\right)$, where $\ext_i$ is specified in property~\ref{property:partition-binding} of Lemma~\ref{lem:partition2}. If $c=1$ and the prover generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he runs $U$ and check whether every copy except the $i$-th copy would be accepted. If all $m-1$ copies accepts, he reply with the $i$-th copy, otherwise reply $\bot$. If $c=0$ and the prover failed to generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he runs $U_{trivial}$ and repies. If $c=1$ and the prover failed to generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he replies with $\bot$. \footnote{Recall that $c=0$ is the testing round and $c=1$ is the Hadamard round.}



%We denote the random variable the verifier would get on the Hadamard round as $z_{composite}$. Also define $(d,z_{composite}) \defeq (\Acc, z_{composite}) + (1-|z_{composite}|)(\Rej,\bot)$ \hannote{correct notation?}


Denote the result we would get when $c=1$ by $(d,z_{composite,i})$.

By Lemma~\ref{lem:trivial-4-round-strategy} and property~\ref{property:partition-binding} of Lemma~\ref{lem:partition2}, the above strategy is accepted with probability $1-\negl(n)$ when $c=0$. Since the prover's strartegy is also efficient, by Lemma~\ref{lem:naive-qpip0-binding}, 
\begin{align}
    (d,z_{composite,i})\approx_{c, O(\eps)}(d,z_{ideal,i})
\end{align}



By construction, when $G_{i,1,\gamma}G_{i-1,1,\gamma} \cdots G_{2,1,\gamma}G_{1,1,\gamma}$ succeeded, the corresponding output would be $z_{good,i}$. Also note that this is the only case where the verifier won't reject, so $(d,z_{composite,i})=(d,z_{good,i})$, where $(d,z_{good,i})$ is defined as: 

$$\begin{cases}
					 (d,z_{good,i}) \la (\Acc, z_{good,i}/|z_{good,i}|) & \text{with probability } |z_{good,i}|\\
					(d,z_{good,i}) = (\Rej,\bot)  & \text{otherwise } 
				\end{cases}$$.


% where  $(d,z)_{good,i} \defeq (\Acc, z_{good,i}) + (1-|z_{good,i}|)(\Rej,\bot)$ \hannote{correct notation? operational def?} . 


Therefore

\begin{align}
    (d,z_{good,i})\approx_{c, O(\eps)}(d,z_{ideal,i}).
\end{align}

Average over $i\in[m]$ we get

\begin{align}
    (d,z_{good})\approx_{c, O(\eps)}(d,z_{ideal}).
\end{align}
% \hannote{do we lose a factor of $m$?}
Recall that by Eq~\ref{eq:z-z-good} we have $\norm{z-z_{good}}_1 \leq \eps$ if we pick $m=O(1/\eps^2), T=O(1/\eps^2),\gamma_0=\eps^8$, which implies 
\begin{align}
    (d,z)\approx_{c, O(\eps)}(d,z_{good}).
\end{align}

Therefore  we have  
\begin{align}
     (d,z)\approx_{c, O(\eps)}(d,z_{ideal}).
\end{align}
%\hannote{the composition of z ideal and triangle ineq is sketchy lol. Also need to specify different z ideal}

 
\end{proof}





