\section{Delegation Protocol for Fully Classical Client}

%\hannote{In this section, we modify the construction of \cite{FOCS:Mahadev18a} to show that a $\QPIP_1$ protocol for $\SampBQP$ implies a $\QPIP_0$ for $\SampBQP$.}

% We then extend our scheme for $\QPIP_0$ using results from \cite{FOCS:Mahadev18a}.

In this section, we combine \cref{QPIP1thm} with results from \cite{FOCS:Mahadev18a} to create a delegation protocol for $\SampBQP$ for fully classical clients. To boost the soundness, we need  polynomial \Ethan{Wording is strange/misleading} rounds, so we use results from \cite{parallelrep} to run polynomially many copies in parallel and get a constant-round protocol.


%Subprotocol for Quantum Measurements
% \subsection{$\QPIP_0$ for BQP?}
% \hannote{Ethan old description before parallel rep.}
% As a warm-up, we  restate the construction in \cite{FOCS:Mahadev18a}, which shows that $\QPIP_1$ protocol for $\BQP$ implies a $\QPIP_0$ for $\BQP$.

% Let $\rho$ be an $n$-qubit state. Let $h$ be an n-bits string called the \emph{basis choice}. That is, $h_i=0$ indicates that the $i$-th qubit of $\rho$ is to be measured in the standard basis, while $i=1$ indicates Hadamard basis measurement instead. Let $D_{\rho, h}$ be the distribution of the corresponding measurement results.



\subsection{Mahadev's measurement protocol}


\Ethan{Half of this discussion is from Han-Hsuan}

In her groundbreaking work, Mahadev~\cite{FOCS:Mahadev18a} gave a 4-round $\QPIP_0$ protocol to let a $\BQP$ machine ``commit a $XZ$ measurement" to a classical machine.
\Ethan{Mahadev's end result is QPIP0 BQP.
Two steps. One is measurement proto.
The other is combine with MF.
Break the previous sentence into two sentences accordingly. Something like the following:

Mahadev's end results in groundbreaking work 4 round protocol for BQP. At the core it is a 4 round protocol to let BQP prover commit XZ measurement to a classical machine.
}
Intuitively, the protocol allows the prover to commit to a state $\rho$ and the verifier to choose a measurement basis $h$ and learn a corresponding measurement outcome $M_{XZ}(\rho, h)$ \Ethan{Actually define this notation by cutting-pasting $h$ from verifier's input}.
\Ethan{Remove the next sentences or move to later}
Note that even a honest prover has complete freedom in choosing $\rho$;
what this protocol actually does is let the prover commit to a particular measurement on $\rho$.
This is good enough for our application, since we will feed the measurement results into the verification of $\QPIP_1$ protocol to ensure that the prover pick the history state as $\rho$ as we will show next.
We now describe the protocol while omitting the implementation details.

\Ethan{Check tone, this is intro/interface}

\begin{protocol}{Mahadev's measurement protocol $\PiMeasure=(\PMeasure, \VMeasure)$}
\label{proto:urmila4}

Inputs:
\begin{itemize}
	\item Common input: Security parameter $1^\lambda$ where $\lambda\in\bbN$.
	\item Prover's input: a state $\rho\in\cB^{\otimes n}$ for the verifier to measure.
	\item Verifier's input:
			a string $h \in \{0,1\}^n$ that specifies the measurement he wants to make: if $h_i=0$, he wants a $X$ measurement on $i$-th qubit. If $h_i=1$, he wants a $Z$ measurement on $i$-th qubit.  
\end{itemize}

Protocol:
\begin{enumerate}
	\item \label{step:measure1} The verifier generates a public and secret key pair $(pk, sk)\leftarrow\cVMeasure{1}(1^\lambda, h)$. It sends $pk$ to the prover.
	\item \label{step:measure2} The prover generates $(y, \sigma)\leftarrow\cPMeasure{2}(pk, \rho)$.
		$y$ is a classical ``commitment", and $\sigma$ is some internal state.
		He sends $y$ to the verifier.
	\item \label{step:measure3} The verifier samples $c\xleftarrow{\$}\zo$ uniformly at random and sends it to the prover. $c=0$ indicates what's called a ``testing round", and $c=1$ indicates a ``Hadamard round".
	\item \label{step:measure4} The prover generates a classical string $a\leftarrow\cPMeasure{4}(pk, c, \sigma)$ and sends it to back to the verifier.
	\item \label{step:output} If it's a testing round ($c=0$), then the verifier generates and outputs $o\leftarrow\cVMeasure{T}(pk, y, a)$, where $o\in\set{\Acc, \Rej}$. \Ethan{Just say testing and acc/rej}
		If it's \Ethan{No abbreviations} a Hadamard round ($c=1$), then the verifier generates and outputs $v\leftarrow\cVMeasure{H}(sk, h, y, a)$.
\end{enumerate}
\end{protocol}

The verifier only learns the measurement outcome on a Hadamard round.
The protocol achieves a ``binding" property that gives guarantees against cheating provers.

% \begin{definition}
% With loss of generality,  we can assume that the testing round verification is deterministic. We denote the set of strings $a$ \Ethan{Font makes this $a$ look screwy} accepted by the verifier in the testing round with $(pk,y)$ as $\Acc_{pk,y}$. \hannote{do  i actually use this}
% \end{definition}

\begin{lemma}\label{lem:urmila-binding}[binding property of Protocol~\ref{proto:urmila4}\cite{FOCS:Mahadev18a}]
	Let $\PMeasureStar$ be a $\BQP$ cheating  prover for $\PiMeasure$ and $\lambda$ be the security parameter. Under the QLWE assumption, if $\PMeasureStar$ passes the testing round with probability $1-\negl(\lambda)$, then there exists some $\rho$ so that for all verifier's input $h \in \zo^n$, the verifier's outputs on the Hadamard round is computationally indistinguishable from $M_{XZ}(\rho, h)$.
\iffalse	
	Suppose that for all $\lambda\in\bbN$ and $h\in\zo^*$ \Ethan{or $\zo^n$?},
	$\PMeasureStar$ passes the testing round with probability $1-\negl(\lambda)$.
	Then, under the QLWE assumption, there exists some $\rho$ so that for all $h$,
	the verifier's outputs on the Hadamard round is $\negl(\lambda)$-computationally indistinguishable from $M_{XZ}(\rho, h)$.
\fi
\end{lemma}

We also mention a fact that will be useful later.
\begin{fact}
\label{lem:trivial-4-round-strategy}
   There exist a prover strategy for $\PiMeasure$ that is accepted with probability $1-\negl{\lambda}$ \Ethan{Changed n to lambda here, see what does it affect} in the testing.
\end{fact}

\Ethan{Introduce $(U_{trivial,0},U_{trivial})$ later corresponding to the ``honest" prover}

We now use $\PiMeasure$ to transform our $\QPIP_1$ Protocol for $\SampBQP$, $\PiSamp=(\PSamp, \VSamp)$, to a corresponding $\QPIP_0$ protocol $\PiNaive$ in a natural way.
Recall that in $\PiSamp$ the verifier learns the XZ measurement outcome of the prover's message.
In PiInt We let the verifier use $\PiMeasure$ to learn...

\begin{protocol}{Intermediate $\QPIP_0$ protocol $\PiNaive$ for a $\SampBQP$ problem $(D_x)_{x\in\set{0, 1}^*}$}
	\label{proto:qpip0_naive}

	Inputs:
	\begin{itemize}
		\item Security parameter $1^\lambda$ where $\lambda\in\bbN$
		\item Error parameter $\varepsilon\in(0, 1)$
		\item Classical input $x\in\zo^n$ to the $\SampBQP$ instance
	\end{itemize}

	Protocol:
	\begin{enumerate}
		\item \label{step:naive1} The verifier chooses a $XZ$-measurement $h$ from the distribution specified in \stepref{qpip1-verify} of $\PiSamp$.
		\item \label{step:naive2} The prover prepares $\rho$ by running \stepref{qpip1-state-gen} of $\PiSamp$.
		\item \label{step:urmila-in-naive} The verifier and prover run $(\PMeasure(\rho), \VMeasure(h))(1^\lambda)$.
		If it's a testing round, the verifier accepts or rejects based on the outcome of $\PiMeasure$.
		If it's a Hadamard round, the verifier obtains $v$.
		\item \label{step:naive-output} If it's a Hadamard round, the verifier finishes the verification step of Protocol~\ref{ProtoQPIP1} by generating and outputting $(d, z)$
			
	\end{enumerate}
\end{protocol}

Note that in $\PiNaive$ the verifier only learns the output in Hadamard round.
So $\PiNaive$ is not a $\QPIP_0$ with good completeness or soundness.
On the other hand, it also has a binding property, which we will use to achieve completeness and soundness in \Cref{sec:qpip0}.

\begin{lemma}\label{lem:naive-qpip0-binding}[binding property of $\PiNaive$]
	Let $\Pstar$ be a cheating $\BQP$ prover for $\PiNaive$ which passes the testing round with probability $1-\negl(\lambda)$.
	Then, under the QLWE assumption, the verifier's output in the Hadamard round satisfies
		$$(d, z)\approx_{c, \varepsilon}(d, z_{ideal}).$$
\end{lemma}

\begin{proof}
\Ethan{I haven't looked at this yet}
By Lemma~\ref{lem:urmila-binding}, if the prover passes the testing round with probability $1-\negl(n)$, there exist a $\rho$ such that $\norm{z_{commit}- M_{XZ}(\rho,h)}_q \leq \negl(n)$. Note that the prover can choose to abort, so $z_{commit}$ and $\rho$ are subnormalized. Let $Ver$ be the verification operation run by Protocol~\ref{ProtoQPIP1} on the measurement outcome. \hannote{describe better} Since $Ver$ is an efficient process and $Ver(z_{commmit})+p_{abort}(\Rej,\bot)=(d,z_{naive})$, we have that 

\begin{equation} \label{eq:z=verM}
    \norm{(d,z_{naive})-(Ver( M_{XZ}(\rho,h))+p_{abort}(\Rej,\bot))}_q \leq \negl(n).
\end{equation}
\hannote{actually true with subnormalize shit?}
 By Theorem~\ref{QPIP1thm}, for all $\rho$, 
 \begin{equation}
     \norm{Ver(M_{XZ}(\rho,h))-(d,z_{ideal})} \leq O(\eps).
 \end{equation}
   Combined with Equation~\ref{eq:z=verM} and Lemma~\ref{lem:computational-triangle0}, and note that $\norm{(\Rej,\bot)-(d,z_{ideal})}=0$, we have that
   \begin{equation}
       \norm{(d,z_{naive})-(d,z_{ideal})}_q\leq O(\eps)
   \end{equation}
\end{proof}


\subsection{$\QPIP_0$ protocol for $\SampBQP$} \label{sec:qpip0}
%Parallel Repetition of the Measurement Subprotocol

\Ethan{Find a good place for this:

On the protocol's fourth message, the prover can choose to abort by sending $a=\bot$. This is useless for the cheating prover but useful for proving one of our theorems.}

The following protocol is a $\QPIP_0$ protocol for $\SampBQP$

$\forall c\in\bbN$ Soundness = $O(T^{-c})$

Given inverse poly p(T), we can parameterize the protocol to have soundness p(T)


%	\label{ProtoQPIP1}

\Ethan{TODO add discussion about parallel rep}

\Ethan{Define in words first, and use the protocol box to introduce notations

unfold for the sake of convenience in analysis

verifier h1 to hm, prover generates whatever it should generate (tensor of whatever),
pki ski expand all, use vec.

}

We now introduce our $\QPIP_0$ protocol $\PiSampZ$ for $\SampBQP$.
It is essentially a $m$-fold parallel repetition of $\PiNaive$.
However, instead of choosing whether to run test or Hadamard round randomly each round,
we run $m-1$ test rounds and only one Hadamard round.

\begin{protocol}{$\QPIP_0$ protocol $\PiSampZ$ for $\SampBQP$}
\label{proto:QPIP0samp}

Inputs:
	\begin{itemize}
		\item Security parameter $1^\lambda$ for $\lambda\in\bbN$.
		\item Accuracy paramter $1^{1/\varepsilon}$ for the $\SampBQP$ instance
		\item Input $x\in\zo^{\poly(\lambda)}$ for the $\SampBQP$ instance
	\end{itemize}

Ingrediant: Let $m=O(1/\varepsilon^2)$ be the number of parallel repetitions to run.
    
Protocol:
\begin{enumerate}
	\item The verifier generates $m$ independently copies of basis choices $\vec{h}=(h_1,\ldots,h_m)$ as in \stepref{naive1} of $\PiNaive$
	\item The prover prepares $\rho^{\otimes m}$ on inputs $1^\lambda$, $1^{1/\varepsilon}$, and $x$. Each copy of $\rho$ is prepared as in \stepref{naive2} of $\PiNaive$
	\item The verifier generates $m$ key pairs for $\PiMeasure$, $\vec{pk}=(pk_1,\ldots,pk_m)$ and $\vec{sk}=(sk_1,\ldots,sk_m)$, on inputs $1^\lambda$ and $\vec{h}$, as in \stepref{measure1} of $\PiMeasure$.
		It sends $\vec{pk}$ to the prover.
	\item The prover generates $\vec{y}=(y_1,\ldots,y_m)$ and $\sigma$ on inputs $\vec{pk}$ and $\rho^{\otimes m}$ as in \stepref{measure2} of $\PiMeasure$.
		It sends $\vec{y}$ to the verifier.
	\item The verifier samples $r\xleftarrow{\$}[m]$ which is the copy to run Hadamard round for.
		For $1\leq i\leq m$, if $i\ne r$ then set $c_i\leftarrow 0$, else set $c_i\leftarrow 1$.
		It sends $\vec{c}=(c_1,\ldots,c_m)$ to the prover.
	\item The prover generates $\vec{a}$ on inputs $\vec{pk}, \vec{c}, \sigma$ as in \stepref{measure4} of $\PiMeasure$, and sends it back to the verifier.
	\item \label{step:multi-testing}
		The verifier computes the outcome for each round as in \stepref{output} of $\PiMeasure$.
		If any of the testing round copies are rejected, the verifier outputs $(\Rej, \bot)$.
		Else, it outputs the result from the Hadamard round copy.
\end{enumerate}
\end{protocol}

\Ethan{TODO Fix proof notations. Like U0, U notations might've been undefined; see parallel rep paper}

\begin{theorem}\label{thm:qpip0}
	$\PiSampZ$ is a $\QPIP_0$ protocol for $\SampBQP$ with $\negl(n)$ completeness error and computational soundness. 
	\Ethan{Its proof currently only shows $O(\varepsilon)$ accuracy.}
\end{theorem}


The intuition behind this theorem is that the we send out $m$ independent copies of the naive $\QPIP_0$ and do testing on randomly chosen $m-1$ copies of them, and do Hadamard round and calculate results from the remaining one copy. Therefore if the prover want to cheat, i.e. send something not binding in the Hadamard round copy, he would be caught with probability $1-1/m$. However, the prover is quantum, so he might create quantum correlations that let him cheat with probability more than $1/m$. To prove that such kind of cheating is impossible, we use the following partition lemma from \cite{parallelrep}, which intuitively says that there exist efficient projectors $G_{0,i}$ and $G_{1,i}$ which splits a quantum state in the prover's   internal space into a part that is rejected with high probability in the testing round of $i$-th copy and a part that is accepted with high probability.  $G_{0,i}$ and $G_{1,i}$ need to be efficient because Protocol~\ref{proto:urmila4} only gives computational indistinguishability. Once we have $G_{0,i}$ and $G_{1,i}$, we can split up the prover's internal state $\ket{\psi}$ like conditional probabilistic events. For example, $G_{0,3} G_{1,5} \ket{\psi}$ corresponds to the events of passing the testing round on fifth copy then fails the the testing round on the third copy. We split the state sub-normalized states corresponding to the prover cheating on different copies and show that the sum of probabilities corresponding to bad states can't be more than $1/m$. {The actual proof is more complicated than this sketch because the $G$'s don't commute with each other, so we need to handle the splitting carefully.}

%Let $S_m$ be sets of $\{c\}$ such that only one of the $c_i=1$.
\begin{lemma}[partition lemma (revision of Lemma 3.5 of \cite{parallelrep}\footnote{$G_{0}$ and $G_{1}$ of this version are created from doing $G$ of \cite{parallelrep} and post-select on the $th$ register being $0$ or $1$ then discard $ph,th,in$. Property~\ref{property:partition-err} corresponds to Property~1. Property~\ref{property:partition-testing}corresponds to Property~4, with $2^{m-1}$ changes to $m-1$ because we only have $m$ possible choices of $\{c\}$. Property~\ref{property:partition-binding} corresponds to Property~5. Property~\ref{property-partition-norm-sum} comes from the fact that $G_0$ and $G_1$ are post-selections of orthogonal results of the same $G$.})]\label{lem:partition2}
Let $(U_0,U)$ be a prover's strategy in Protocol~\ref{proto:QPIP0samp}, where $U_0$ is the how the prover generates answer in the second round, and $U$ is how the prover generates answer in the fourth round. Denote the string $0^{i-1}10^{m-i} \in \zo^m $ as $e_i$.  Let $\gamma_0 \in[0,1]$, and $T\in \mathbb{N}$ such that $\gamma_0=1/\poly(n)$ and $T=\poly(n)$.

 For all $i\in[m]$, $\gamma \in \L\{\frac{\gamma_0}{T},\frac{2\gamma_0}{T},\dots,\frac{T\gamma_0}{T}\R\}$, there exist two efficient quantum circuit $G_{0,i,\gamma}$ and $G_{1,i,\gamma}$ \Ethan{Not consistent with the cited paper; typeof(G0, G1) aren't q circuits} such that for all (possibly sub-normalized)  quantum state $\ket{\psi}_{\regX,\regZ}$,  

\begin{align}
    G_{0,i,\gamma}\ket{\psi}_{\regX,\regZ} \defeq& \ket{\psi_{0,i,\gamma}}_{\regX,\regZ} \\ G_{1,i,\gamma}\ket{\psi}_{\regX,\regZ} \defeq& \ket{\psi_{1,i,\gamma}}_{\regX,\regZ}  \\
    \ket{\psi}_{\regX,\regZ} =&   \ket{\psi_{0,i,\gamma}}_{\regX,\regZ}+ \ket{\psi_{1,i,\gamma}}_{\regX,\regZ}+\ket{\psi_{err,i,\gamma}}_{\regX,\regZ}
\end{align}

% $$ \ket{\psi}_{\regX,\regZ} =  G_{0,i,\gamma}\ket{\psi}_{\regX,\regZ}+ G_{1,i,\gamma}\ket{\psi}_{\regX,\regZ}+\ket{\psi_{err}}_{\regX,\regZ},$$

 

 
  Note that $G_{0,i,\gamma}$ and $G_{1,i,\gamma}$ has failure probabilities, and this is reflected by the fact that $\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}$ and $\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}$ are  sub-normalized. $G_{0,i,\gamma}$ and $G_{1,i,\gamma}$ depend on $(U_0,U)$ and $pk,y$. \hannote{check}

 


Furthermore, the following properties are satisfied for all $i\in[m]$.
%
\begin{enumerate}
    \item \label{property:partition-err}  $$\E_{\gamma}\|\ket{\psi_{err,i,\gamma}}_{\regX,\regZ}\|^2 \leq \frac{6}{T}+\negl(n),$$
    
    where the averaged is over uniformly sampled $\gamma$. This also implies
    \begin{align}
        \E_{\gamma}\|\ket{\psi_{err,i,\gamma}}_{\regX,\regZ}\| \leq \sqrt{\frac{6}{T}}+\negl(n)
    \end{align}
by Cauchy's inequality.
    
        \item \label{property:partition-testing}
For all $\{pk\}$, $\{y\}$, fixed $\gamma$, and  $j\neq i$, we have 
 
%      \begin{align*}
%  \Pr\left[M_{\regX_i}\circ U\frac{\ket{\{c\}}_{\regC}\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_0}_{\regX,\regZ}\|}\in \Acc_{pk_i,y_i}\right]\leq (m-1)\gamma+\negl(\secpar).
%  \end{align*}

%  Define
%  $$\ket{\widetilde{\psi_{0,i,\gamma}}}\defeq U\frac{\ket{\{c\}}_{\regC}\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_0}_{\regX,\regZ}\|}.$$
%  We have
%  \begin{align}
%      \vev{\widetilde{\psi_{0,i,\gamma}}|P_{i,pk_i,y_i,acc}|\widetilde{\psi_{0,i,\gamma}}} \leq (m-1)\gamma+\negl(\secpar),
%  \end{align}
 \begin{align}
    \norm{ P_{i,pk_i,y_i,acc} \circ U\frac{\ket{e_j}_{\regC}\ket{\psi_{0,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_0}_{\regX,\regZ}\|}}^2 \leq (m-1)\gamma_0+\negl(\secpar),
 \end{align}
 
 
where $P_{i,pk_i,y_i,acc}$ are projector to the states that $i$-th testing round accepts with $pk_i,y_i$, including the last measurement the prover did before sending $\{a\}$.  This means that $\ket{\psi_{0,i,\gamma}}$ is rejected by $i$-th testing round with high probability.


    \item \label{property:partition-binding}
    
    % $\{c\}\in S_m$ such that $c_i = 0$
For all $\{pk\}$, $\{y\}$, fixed $\gamma$, and $j\neq i$, there exists an efficient quantum algorithm $\ext_i$ such that 

\begin{align}
     \norm{P_{i,pk_i,y_i,acc} \circ \ext_i\left(\frac{\ket{e_j}_{\regC}\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_1}_{\regX,\regZ}\|}\right)}^2 =1-\negl(\secpar).
\end{align}

% \begin{align*}  
%   \Pr\left[M_{\regX_i}\circ \ext_i\left(\frac{\ket{\{c\}}_{\regC}\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_1}_{\regX,\regZ}\|}\right)\in \Acc_{pk_i,y_i}\right]=1-\negl(\secpar).
%   \end{align*}
This will imply that    $\ket{\psi_{1,i,\gamma}}$ is binding to $i$-th Hadamard round.

\item \label{property-partition-norm-sum}
  For all $\gamma$, 
  \begin{align}
    \norm{\ket{\psi_{0,i,\gamma}}}^2+ \norm{\ket{\psi_{1,i,\gamma}}}^2 \leq  \norm{\ket{\psi}}^2 
\end{align}

  
% \item \hannote{added by me..not needed?}

% $$\vev{\psi_{0,i,\gamma}|\psi_{1,i,\gamma}} = \negl(n)$$
 


\end{enumerate}
\end{lemma}







% \begin{proof}
% Step~\ref{step:sum-ob}: 
% \begin{align}
%   ( G_{0,i,\gamma}+G_{1,i,\gamma}) \ket{\psi}_{\regX,\regZ}
%   &= \ket{\psi_{0,i,\gamma}}_{\regX,\regZ}+\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}
% \end{align}
% \end{proof}

We also need the following technical lemma.
\begin{lemma}\label{lem:samp-tech}
For any state $\ket{\psi}$,  $\ket{\phi}$ and projectors $\{P_z\}$ such that $\sum_z P_z \leq Id$ and $P_z P_{z'} =0 $ for all $z\neq z'$, we have
$$  \sum_z |\vev{\psi|P_z|\phi}| \leq \norm{\psi}\norm{\phi} $$
\end{lemma}
\begin{proof}
\begin{align}
    \sum_z |\vev{\psi|P_z|\phi}| =&\sum_z|\vev{\psi|P_zP_z|\phi}| \nn \\
    \leq& \sum_z \norm{\bra{\psi}P_z} \norm{ P_z\ket{\phi}}  \nn \\ \leq&  \sqrt{\sum_z \norm{P_z\ket{\psi}}^2} \sqrt{\norm{ P_z\ket{\phi}}^2}     \nn \\
    \leq& \sqrt{\norm{\sum_z P_z\ket{\psi}}^2 } \sqrt{\norm{\sum_z P_z\ket{\phi}}^2 } \nn \\
    \leq & \norm{\ket{\psi}}\norm{\ket{\phi}},
\end{align}
where we used Cauchy's inequality on the second and third line and $P_z P_{z'} =0 $ on the fourth line.
\Ethan{Typo on line 3?}
\end{proof}



Now we are ready to prove Theorem~\ref{thm:qpip0}
\begin{proof}
Completeness is trivial.


For soundness, We begin by considering the state $\ket{\psi}$ the prover in Protocol~\ref{proto:QPIP0samp} hold before he receives $\{c\}$. We denote the corresponding Hilbert space as $H_{\regX,\regZ}$.


For all $k\leq m$, $d\in \zo^k$, and $\ket{\psi} \in H_{\regX,\regZ}$, define

$$\ket{\psi_{d,\gamma}}\defeq G_{d_k,k,\gamma}G_{d_{k-1},k-1,\gamma}\cdots G_{d_2,2,\gamma} G_{d_1,1,\gamma} \ket{\psi}$$

By Lemma~\ref{lem:partition2}, we have  

\begin{align} \label{eq:partition-string}
    \ket{\psi} =& \ket{\psi_{0,\gamma}}+\ket{\psi_{1,\gamma}}+\ket{\psi_{err,1,\gamma}} \nn \\
    =& \ket{\psi_{0,\gamma}}+\ket{\psi_{10,\gamma}}+\ket{\psi_{11,\gamma}}+\ket{\psi_{err,1,\gamma}}+\ket{\psi_{err,2,\gamma}} \nn \\
    =& \ket{\psi_{0,\gamma}}+\ket{\psi_{10,\gamma}}+\ket{\psi_{110,\gamma}}+\cdots+\ket{\psi_{1^{m-1}0,\gamma}}+\ket{\psi_{1^{m-1}1,\gamma}} \nn \\
    &+\ket{\psi_{err,1,\gamma}}+\ket{\psi_{err,2,\gamma}}+\cdots+\ket{\psi_{err,m,\gamma}}, 
\end{align}

where we abuse the notation and use $\ket{\psi_{err,i,\gamma}}$ to denote the error state we get from decomposing $\ket{\psi_{1^{i-1},\gamma}}$. %\hannote{Note that the prover's state is actually a mixed state. In particular, $\ket{\psi}$ depends on $pk$ and we are considering the mixed state averaged over verifier's choice of $pk$.}

By Property~\ref{property-partition-norm-sum} of Lemma~\ref{lem:partition2}, we have
\begin{align} \label{eq:bad-term-sum}
    \norm{\ket{\psi}}^2 \geq& \norm{\ket{\psi_{0,\gamma}}}^2+\norm{\ket{\psi_{1,\gamma}}}^2 \nn \\
    \geq& \norm{\ket{\psi_{0,\gamma}}}^2+
    \norm{\ket{\psi_{10,\gamma}}}^2+ \norm{\ket{\psi_{11,\gamma}}}^2 \nn \\
    \geq& \norm{\ket{\psi_{0,\gamma}}}^2+
    \norm{\ket{\psi_{10,\gamma}}}^2+ \norm{\ket{\psi_{110,\gamma}}}^2 +\cdots  \nn \\
    &+ \norm{\ket{\psi_{1^{m-1}0,\gamma}}}^2+ \norm{\ket{\psi_{1^{m-1}1,\gamma}}}^2
\end{align}

Denote the projector in $H_{\regX,\regZ}$ corresponding to outputting string $z$ when doing Hadamard on $i$-th copy as

$$P_{acc,i,z}.$$
Note that $P_{acc,i,z}$ also depends on $\{\pk\},\,\{y\}$ and  $(sk_i,h_i,y_i)$ since it includes the measurement the prover did before sending $a$,  verifier's checking on $(m-1)$ copies of testing rounds, and  the verifier's final computation from $(sk_i,h_i,y_i,a_i)$.

Since the verifier only accepts if all $(m-1)$ copies of testing rounds accepts, for all $j\neq i$,

$$P_{acc,i,z}=P_{acc,i,z}P_{j,pk_j,y_j,acc}.$$

And therefore by Property~\ref{property:partition-testing} of Lemma~\ref{lem:partition2}, we have that for all $j <i-1$\hannote{problem with $e_j$ or $e_i$}

\begin{align} \label{eq:rejected-d}
    \norm{P_{acc,i,z} U \ket{e_i, \psi_{1^j0,\gamma}}}^2
    =& \norm{P_{acc,i,z}P_{j,pk_j,y_j,acc} U \ket{e_i}\, G_{0,j+1,\gamma}\ket{\psi_{1^j,\gamma}}  }^2 \nn \\
    \leq& \norm{P_{j,pk_j,y_j,acc} U \ket{e_i}\, G_{0,j+1,\gamma}\ket{\psi_{1^j,\gamma}}  }^2 \nn \\
    \leq& (m-1)\gamma_0+\negl(n) 
\end{align}


Denote the string $0^{i-1}10^{m-i} \in \zo^m $ as $e_i$. The output string corresponding to $\ket{\psi} \in H_{\regX,\regZ}$ when $c=e_i$ is then 




$$z_i\defeq \E_{pk,y} \sum_z \proj{z} \cdot \vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi},$$
where $\ket{e_i,\psi}=\ket{e_i}_\regC\ket{\psi}_{\regX,\regZ}$ and $U$ is the unitary the prover applies on the last round. Note that we have averaged over $pk, y$ where as previously everything has fixed $pk$ and $y$. \hannote{add description about  averaging $pk$ here.}

Since $\{c\}$ is drawn  from $e_i$ with uniformly random $i\in [m]$, we have 
$$ z=\frac{1}{m} \sum_i z_i= \frac{1}{m} \sum_i \sum_z \proj{z} \cdot \vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi},$$ 
	where we represent the random variable $z$ as a real non-negative diagonal matrix, with the matrix entries begin probabilities. Note that $z$ is "sub-normalized", i.e. $\tr (z)= \text{probability of getting accepted} \leq 1$.






Define 

\begin{align}
    z_{good,i}=\E_\gamma \sum_z \proj{z} \cdot \vev{e_i,\psi_{1^{i-1}1,\gamma}|U^\dag P_{acc,i,z} U|e_i,\psi_{1^{i-1}1,\gamma}}
\end{align}

Splitting $\ket{\psi}$ with Equation~\ref{eq:partition-string}, 
%\hannote{gamma..}

\begin{align}
    \ket{\psi}=& \L. \ket{\psi_{0,\gamma}}+\ket{\psi_{10,\gamma}}+\ket{\psi_{110,\gamma}}+\cdots+\ket{\psi_{1^{i-1}0,\gamma}}+
    \ket{\psi_{1^{i-1}1,\gamma}} \R. \nn \\
     +& \L.\ket{\psi_{err,1,\gamma}}+\ket{\psi_{err,2,\gamma}}+\cdots+\ket{\psi_{err,i,\gamma}}\R. \nn \\
     =& \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} +\ket{\psi_{1^i,\gamma}} +\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}
\end{align}


we have 

\begin{align}
    z_i =& \sum_z \proj{z} \cdot \vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi} \nn \\
    =& \sum_z \proj{z} \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}} +\bra{\psi_{1^i,\gamma}} +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} \R]U^\dag  P_{acc,i,z} U\nn \\
    &\L[ \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} +\ket{\psi_{1^i,\gamma}} +\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}\R]  \nn \\
    =& \E_\gamma \sum_z \proj{z} \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}} +\bra{\psi_{1^i,\gamma}} +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} \R]U^\dag  P_{acc,i,z} U\nn \\
    &\L[ \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} +\ket{\psi_{1^i,\gamma}} +\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}\R]  \nn \\
    =& z_{good,i}+ \E_\gamma \sum_z \proj{z} \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U   \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}+
    \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}}  \R. \nn \\
      +&  \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \nn \\
    +& \sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U  \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} 
    +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \nn \\
    +&\L.\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \R] , \nn     
    %=& z_{good,i} +(\text{terms with } \psi_{1^j0},\, j\neq i ) + (\text{terms with } \psi_{1^{i-1}0}) +(\text{terms with }err ) 
\end{align}

%  U^\dag  P_{acc,i,z}U

% \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} 
% \ket{\psi_{1^i,\gamma}} 
% \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}  

 where we omitted writing out $e_i$ starting the second line. We have
\begin{align} \label{eq:zi-zgoodi}
    &\tr|z_i-z_{good,i}|   \nn \\
    \leq&  \sum_z  \L| \E_\gamma \L[\sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U   \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}+
    \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}}  \R. \R. \nn \\
      +&  \sum_{k=0}^{i-1} \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U\sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}}
    +\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \nn \\
    +& \sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U  \sum_{j=0}^{i-1} \ket{\psi_{1^j0,\gamma}} 
    +\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \nn \\
    +&\L.\L.\sum_{k=1}^{i}\bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \sum_{j=1}^{i}\ket{\psi_{err,j,\gamma}} \R]\R| \nn \\  %%%%%%%%%%%
    \leq&  \sum_z   \E_\gamma \L[\sum_{k=0}^{i-1} \sum_{j=0}^{i-1} \L| \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U    \ket{\psi_{1^j0,\gamma}} \R|+
    2 \sum_{k=0}^{i-1} \L|\bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \R|  \R.  \nn \\
      +&  2 \sum_{k=0}^{i-1}\sum_{j=1}^{i}\L| \bra{\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U\ket{\psi_{err,j,\gamma}}\R|    
    +2 \sum_{j=1}^{i}\L|\bra{\psi_{1^i,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{err,j,\gamma}}\R| \nn \\
    +&\L. \sum_{k=1}^{i}\sum_{j=1}^{i}\L| \bra{\psi_{err,k,\gamma}} U^\dag  P_{acc,i,z}U \ket{\psi_{err,j,\gamma}}\R| \R] \nn \\ %%%%%%%%%
      \leq&  \sum_z   \L[\sum_{k=0}^{i-1} \sum_{j=0}^{i-1} \L| \bra{e_i,\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U    \ket{e_i,\psi_{1^j0,\gamma}} \R|+
    2 \sum_{k=0}^{i-1} \L|\bra{e_i,\psi_{1^k0,\gamma}}U^\dag  P_{acc,i,z}U \ket{e_i,\psi_{1^i,\gamma}} \R|  \R]    +O\L(\frac{m^2}{\sqrt T}\R)\nn \\ %%%%%%%%%
    \leq&  \sum_z   \L[\L| \bra{\psi_{1^{i-1}0,\gamma}}U^\dag  P_{acc,i,z}U    \ket{\psi_{1^{i-1}0,\gamma}} \R|+
    2  \L|\bra{\psi_{1^{i-1}0,\gamma}}U^\dag  P_{acc,i,z}U \ket{\psi_{1^i,\gamma}} \R|  \R]    \nn \\ +&O\L(\frac{m^2}{\sqrt T}+m^2{(m-1)\gamma_0}+m\sqrt{(m-1)\gamma_0}\R)\nn \\ %%%%%%%%% 
    \leq& \norm{\ket{\psi_{1^{i-1}0,\gamma}}}^2+ 2\norm{\ket{\psi_{1^{i-1}0,\gamma}}}+O\L(\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R),
\end{align}
where on the second inequality we used triangle inequality, on the third inequality we used  Lemma~\ref{lem:samp-tech} and property~\ref{property:partition-err} of Lemma~\ref{lem:partition2}, on the fourth inequality we used Lemma~\ref{lem:samp-tech} and Equation~\ref{eq:rejected-d}, and on the last inequality we used Lemma~\ref{lem:samp-tech}. Once again, we omit $e_i$ when it is not relevant. 






% \begin{align}
%     &\vev{e_i,\psi|U^\dag P_{acc,i,z} U|e_i,\psi} \nn \\
%     =& \bra{e_i, \psi_{1^{i-1}1,\gamma}} U^\dag P_{acc,i,z} U \ket{e_i\psi_{1^{i-1}1,\gamma}} +\hannote{poly terms?}+ \negl(n)
% \end{align}

Now we try to  put together all $i\in [m]$. Define
$$z_{good}\defeq \frac{1}{m}\sum_i z_{good,i}.$$

We have 
\begin{align} \label{eq:z-z-good}
    \tr|z-z_{good}| =& \tr\L|\frac{1}{m}\sum_i (z_i-z_{good,i})\R| \nn \\
    \leq&  \frac{1}{m}\sum_i\tr| (z_i-z_{good,i})| \nn \\
    \leq&  \frac{1}{m}\sum_i\L[\norm{\ket{\psi_{1^{i-1}0,\gamma}}}^2+ 2\norm{\ket{\psi_{1^{i-1}0,\gamma}}}+O\L(\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R)\R] \nn \\%%%%%%%%
    \leq&  \frac{1}{m}+ 2\frac{1}{\sqrt m}+O\L(\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R) \nn \\ %%%%%
    =&O\L( \frac{1}{\sqrt m}+\frac{m^2}{\sqrt T}+m\sqrt{(m-1)\gamma_0}\R)
\end{align}

where we used triangle inequality on the second line, Equation~\ref{eq:zi-zgoodi} on the third line, Equation~\ref{eq:bad-term-sum} and Cauchy's inequality on the fourth line.





We now proceeds to prove that $z_{good}$ is close to the ideal distribution. 

For every $i\in [m]$ and every prover strategy $(U_0,U)$ for Protocol~\ref{proto:QPIP0samp}, consider the following composite strategy of the prover for the naive $\QPIP_0$ Protocol, Protocol~\ref{proto:qpip0_naive}. Note that the prover only interact with the verifier in Step~\ref{step:urmila-in-naive} of Protocol~\ref{proto:qpip0_naive} where Protocol~\ref{proto:urmila4} is run, so we describe the prover's action in turns of the four rounds of communication in Protocol~\ref{proto:urmila4}.

The prover tries to run $U_0$ by taking the verifier's input as $i$-th copy of Protocol~\ref{proto:urmila4} in Protocol~\ref{proto:QPIP0samp} and simulating other $m-1$ copies by himself. The prover then picks a uniformly random $\gamma$ and  tries to generate $\ket{\psi_{1^{i-1}1,\gamma}}$ by applying $G_{i,1,\gamma}G_{i-1,1,\gamma} \cdots G_{2,1,\gamma}G_{1,1,\gamma}$. If the prover fails to generate $\ket{\psi_{1^{i-1}1,\gamma}}$, he throws out everything and run $U_{trivial,0}$ described  in  Lemma~\ref{lem:trivial-4-round-strategy} instead. This is possible because all the inputs are classical. On the fourth round, there are four possibilities depending on $c$ and whether the prover generated $\ket{\psi_{1^{i-1}1,\gamma}}$. If $c=0$ and the prover generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he reply with the $i$-th register of $\ext_i\left(\frac{\ket{e_j}_{\regC}\ket{\psi_{1,i,\gamma}}_{\regX,\regZ}}{\|\ket{\psi_1}_{\regX,\regZ}\|}\right)$, where $\ext_i$ is specified in property~\ref{property:partition-binding} of Lemma~\ref{lem:partition2}. If $c=1$ and the prover generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he runs $U$ and check whether every copy except the $i$-th copy would be accepted. If all $m-1$ copies acceptes, he reply with the $i$-th copy, otherwise reply $\bot$. If $c-0$ and the prover failed to generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he runs $U_{trivial}$ and repies. If $c=1$ and the prover failed to generated $\ket{\psi_{1^{i-1}1,\gamma}}$, he replies with $\bot$. \footnote{Recall that $c=0$ is the testing round and $c=1$ is the Hadamard round.}



%We denote the random variable the verifier would get on the Hadamard round as $z_{composite}$. Also define $(d,z_{composite}) \defeq (\Acc, z_{composite}) + (1-|z_{composite}|)(\Rej,\bot)$ \hannote{correct notation?}


Denote the result we would get when $c=1$ by $(d,z_{composite,i})$.

By Lemma~\ref{lem:trivial-4-round-strategy} and property~\ref{property:partition-binding} of Lemma~\ref{lem:partition2}, the above strategy is accepted with probability $1-\negl(n)$ when $c=0$. Since the prover's strartegy is also efficient, by Lemma~\ref{lem:naive-qpip0-binding}, 
\begin{align}
    \norm{(d,z_{composite,i})-(d,z_{ideal,i})}_q \leq O(\eps)
\end{align}



By construction, when $G_{i,1,\gamma}G_{i-1,1,\gamma} \cdots G_{2,1,\gamma}G_{1,1,\gamma}$ succeeded, the corresponding output would be $z_{good,i}$. Also note that this is the only case where the verifier won't reject, so $(d,z_{composite,i})=(d,z_{good,i})$, where  $(d,z)_{good,i} \defeq (\Acc, z_{good,i}) + (1-|z_{good,i}|)(\Rej,\bot)$ \hannote{correct notation? operational def?} . Therefore

\begin{align}
    \norm{(d,z_{good,i})-(d,z_{ideal,i})}_q \leq O(\eps).
\end{align}

Average over $i\in[m]$ we get

\begin{align}
    \norm{(d,z_{good})-(d,z_{ideal})}_q \leq O(\eps).
\end{align}
\hannote{do we lose a factor of $m$?}
Recall that by Eq~\ref{eq:z-z-good} we have $\norm{z-z_{good}}_1 \leq \eps$ if we pick $m,T,\gamma_0=???$ \hannote{tune eps}, which implies 
\begin{align} 
    \norm{(d,z)-(d,z_{good})}_1 \leq \eps
\end{align}

Therefore by Lemma~\ref{lem:computational-triangle0}, we have  
\begin{align}
     \norm{(d,z)-(d,z_{ideal})}_q \leq O(\eps)
\end{align}
\hannote{the composition of z ideal and triangle ineq is sketchy lol. Also need to specify different z ideal}

 
\end{proof}





