\section{Preliminaries}

\subsection{Notations}

Let $\mathcal{B}$ be the Hilbert space corresponding to one qubit. Let $H:\mathcal{B}^{\otimes N}\rightarrow\mathcal{B}^{\otimes N}$ be Hermitian matrices. We use $H\geq0$ to denote $H$ being positive semidefinite. Let $\lambda(H)$ be the smallest eigenvalue of $H$. The ground states of $H$ are the eigenvectors corresponding to $\lambda(H)$. For matrix $H$ and subspace $S$, let $H\big|_S=\Pi_S H \Pi_S$, where $\Pi_S$ is the projector onto the subspace $S$. For a $T$-qubit Hilbert space, let the state $\ket{\widehat{t}}=\ket{1}^{\otimes t}\otimes \ket{0}^{{\otimes (T-t)}}$. Let $\Lambda_c(U)$ denote the gate $U$ controlled on qubit $c$, and $\Lambda^2_{f, s}(U)$ denote the gate $U$ controlled by both $f$ and $s$. I.e. $\Lambda^2_{1, 2}(X_3)$ would be a Toffoli (CCNOT) gate. 

The phase gate and Pauli matrices are denoted as follows.

\begin{definition}
	$P(i)=\begin{pmatrix}1&0\\0&i\end{pmatrix}$, $X=\begin{pmatrix}0&1\\1&0\end{pmatrix}$,
	$Y=\begin{pmatrix}0&-i\\i&0\end{pmatrix}$,
	$Z=\begin{pmatrix}1&0\\0&-1\end{pmatrix}$
\end{definition}

We define a sampling version of $\BQP$, $\SampBQP$, based on \cite{aaronson_2013}.

\begin{definition} [sampling problem]
	A sampling problem $S$ is a collection of probability distributions $(D_x)$, one for each input string $x\in\set{0,1}^n$, where $D_x$ is a distribution over $\set{0,1}^{p(n)}$ for some fixed polynomial $p$.
\end{definition}
    
\hannote{sampling generalize decision blah} \Ethan{That doesn't sound right}

\begin{definition} [$\SampBQP$]
	$\SampBQP$ is the class of sampling problems $S=(D_x)$ for which for all $\varepsilon$ there exists a quantum circuit constructible in time $\poly(|x|, \frac{1}{\varepsilon})$ that, given $x$ as input, samples from from a probability distribution $\tilde{D}_x$ such that $\norm{\tilde{D}_x-D_x}<\varepsilon$.
\end{definition}

\subsection{Quantum Prover Interactive Protocol (QPIP)}
We classify the interaction between a (almost classical) client and a quantum server for sampling problems, extending the classification by \cite{mahadev_delegation}.

\begin{definition}
	A sampling problem $S=(D_x)$ is said to be in $\QPIP_\tau$ with completeness $c$ and soundness $(\delta, s)$ if there exists a pair of algorithms \hannote{ protocols?} $(\bbP, \bbV)$ with the following properties with input $x$:
	\begin{itemize}
		\item $\bbP$ is run by the prover, a $\BQP$ machine, which also has access to a quantum channel that can transmit $\tau$ qubits to the verifier per use.
		\item $\bbV$ is run by the verifier, which is a hybrid machine of a classical part and a limited quantum part. The classical part is a $\BPP$ machine. The quantum part is a register of $\tau$ qubits, on which the verifier can perform arbitrary quantum operations and which has access to a quantum channel which can transmit $\tau$ qubits. At any given time, the verifier is not allowed to possess more than $\tau$ qubits. The interaction between the quantum and classical parts of the verifier is the usual one: the classical part controls which operations are to be performed on the quantum register, and outcomes of measurements of the quantum register can be used as input to the classical part.
		 \item There is also a classical communication channel between the prover and the verifier, which can transmit polynomially\hannote{poly in what} many bits to either direction. 
		 \item The protocol\hannote{?} is run by steps. At any given step, either the verifier or the prover performs computations on their registers and send bits and qubits through the relevant channels to the other party.	\hannote{redundant?} 
		\item (Completeness) After interacting with $\bbP$, $\bbV$ accepts with probability $\geq c$.
		\item (Soundness) Given $\bbP'$, if $(\bbP', \bbV)$ accepts with probability greater than $\delta$, then conditioned on this acceptance, $\bbV$ outputs a distribution $\tilde{D}$ with $\norm{\tilde{D}-D_x}\leq s$.
	\end{itemize}
\end{definition}

\subsection{Projection Lemma}

We use the projection lemma from \cite{kempe_kitaev_regev_2006}, which projects the ground state of the Hamiltonian $H_1$ to the ground space of a Hamiltonian $H_2$ with a large gap.

\hannote{original text?}
\begin{theorem}
	Let $H_1, H_2$ be local Hamiltonians where $H_2\geq0$. Let $K=\ker H_2$.
	$$\exists J=\frac{\poly(\norm{H_1})}{\lambda(H_2|_{K^\bot})}$$
	$$\lambda(H_1+JH_2)\geq\lambda(H_1\big|_K)-\frac{1}{8}$$
\end{theorem}

\subsection{Quantum de Finetti Theorem under Local Measurements}

There are many formulations of quantum de Finetti theorems. We use the one from \cite{BrandÃ£o2017} because we need logarithmic dependence on $|A|$.
\begin{theorem}
	\label{deFinetti}
	Let $\rho^{A_1\ldots A_k}$ be a permutation-invariant state. Then for every $0\leq l\leq k$ there exists states $\set{\rho_i}$ and $\set{p_i}\subset\bbR$ such that
	$$\max_{\Lambda_1,\ldots,\Lambda_l}\norm{(\Lambda_1\otimes\ldots\otimes\Lambda_l)\left(\rho^{A_1\ldots A_l}-\sum_ip_i\rho_i^{A_1}\otimes\ldots\otimes\rho_i^{A_l}\right)}_1\leq\sqrt{\frac{2l^2\ln\abs{A}}{k-l}}$$
\end{theorem}

\subsection{Quantum Homomorphic Encryption Schemes}

\begin{dfn}
	A quantum homomophic encryption scheme is tuple of algorithms $\mathsf{HE}=(\mathsf{HE.Keygen}, \mathsf{HE.Enc}, \mathsf{HE.Dec}, \mathsf{HE.Eval})$ with the following descriptions:
	\begin{itemize}
		\item $\mathsf{Keygen}(1^\lambda)\rightarrow(pk, evk, sk)$
		\item $\mathsf{Enc}_{pk}(\mu)\rightarrow c$
		\item $\mathsf{Dec}_{sk}(c)\rightarrow \mu^*$
		\item $\mathsf{Eval}_{evk}(f, c_1, \ldots, c_l)\rightarrow c_f$
	\end{itemize}
\end{dfn}

Everything also has an implicit dependence on $1^L$, where $L$ is the maximum circuit depth for the homomorphic evaluation.

$\mathsf{HE}$ also satisfies, with all but negligible probability in $\lambda$, that
$$\mathsf{HE.Dec}_{sk}(\mathsf{Eval}_{evk}(f, c_1, \ldots, c_l)=f(\mathsf{HE.Dec}_{sk}(c_0),\ldots,\mathsf{HE.Dec}_{sk}(c_l))$$

We also recall the security definition for a FHE scheme.

\begin{dfn}
	A FHE scheme $\mathsf{HE}$ is IND-CPA secure if, for any polynomial time adversary $\cA$, there exists a negligible function $\mu(\cdot)$ such that
	$$\abs{Pr[\cA(pk, evk, \mathsf{HE.Enc}_{pk}(0))=1]-Pr[\cA(pk, evk, \mathsf{HE.Enc}_{pk}(1))=1]}=\mu(\lambda)$$
	where $(pk, evk, sk)\leftarrow\mathsf{QHE.Keygen}(1^\lambda)$
	\Ethan{Urmila didn't specify quantum adversary here? Also dropped the $1^L$.}
\end{dfn}

\subsection{Security definition for interactive protocols}

\begin{dfn}
	Let $\lambda$ be a security parameter.
	Let $(\bbP, \bbV)$ be an interactive protocol with security parameter $\lambda$.
	Then it is IND-CPA secure if $\forall x\in\set{0,1}^n$ no polynomial time adversary $\cA$ can win \myprotoref{protoIndCPA} with probability better than $\frac{1}{2}+\negl(\lambda)$
\end{dfn}

\floatname{algorithm}{Protocol}
\begin{algorithm}
	\caption{ $\QPIP_1$ protocol for $\SampBQP$}
	\label{ProtoIndCPA}
	\begin{algorithmic}[1]
		\State The challenge picks $b\in\set{0,1}$ at random
		\If{b=1}
			\State The challenger runs the protocol with the adversary, acting as the verifier with input $0^n$
		\Else
			\State The challenger runs the protocol with the adversary, acting as the verifier with input $x$
		\EndIf
		\State $\cA$ attempts to guess $b$
	\end{algorithmic}
\end{algorithm}
\floatname{algorithm}{Algorithm}
