\section{Delegation of Quantum Sampling Problems}

In this section, we formally introduce the task of delegation for quantum sampling problem. We start by recalling the complexity class $\SampBQP$ defined by Aaronson~\cite{aaronson_2013, aaronson_arkhipov_2011}, which captures the class of sampling problems that
are approximately solvable by polynomial-time quantum algorithms.


\begin{definition} [Sampling Problem]
    \label{dfn:sampling-problem}
    A \emph{sampling problem} is a collection of probability distributions $(D_x)_{x\in\set{0, 1}^*}$, one for each input string $x\in\set{0,1}^n$, where $D_x$ is a distribution over $\set{0,1}^{m(n)}$ for some fixed polynomial $m$.
\end{definition}

\begin{definition} [$\SampBQP$]
    $\SampBQP$ is the class of sampling problems $\left(D_x\right)_{x\in\set{0, 1}^*}$ that can be (approximately) sampled by polynomial-size uniform quantum circuits. Namely, there exists a Turing machine $M$ such that for every $n \in \bbN$ and $\eps \in (0,1)$, $M(1^n, 1^{1/\eps})$ outputs a quantum circuit $C$ in $\poly(n, 1/\eps)$ time such that for every $x \in \zo^n$, the output of $C(x)$ (measured in standard basis) is $\eps$-close to $D_x$.
\end{definition}

Note that in the above definition, there is an accuracy parameter $\eps$ and the quantum sampling algorithm only requires to output a sample that is $\eps$-close to the correct distribution in time $\poly(n,1/\eps)$, instead of the stringent requirement of outputting a perfect sample. There are multiple reasons for allowing an inverse polynomial error. For example, conceivable physical realizations of quantum computer may consist of inherent noise. We refer the readers to~\cite{aaronson_2013, aaronson_arkhipov_2011} for the discussion therein on why this better captures the sampling problem solvable by efficient quantum computers. 

We next define what does it mean for a $\QPIP_\tau$ protocol to solve a $\SampBQP$ problem $\left(D_x\right)_{x\in\set{0, 1}^*}$.
Since sampling problem comes with an accuracy parameter $\eps$, we let the prover $P$ and the verifier $V$ receive the input $x$ and $1^\eps$ as common inputs. 
Completeness is straightforward to define, which requires that when the prover $P$ is honest, the verifier $V$ should accept with high probability and output a sample $z$ distributed close to $D_x$ on input $x$. Defining soundness is more subtle. Intuitively, it requires that the verifier $V$ should never be ``cheated'' to accept and output an incorrect sample even when interact with a malicious prover. We formalize this by a strong simulation-based definition, where we require that the joint distribution of the decision bit $d \in \set{\Acc, \Rej}$ and the output $z$ (which is $\bot$ when $d = \Rej$) is $\eps$-close (in either statistical or computational sense) to an ``ideal distribution'' $(d,z_{ideal})$, where $z_{ideal}$ is sampled from $D_x$ when $d = \Acc$ and set to $\bot$ when $d = \Rej$. Note that since the protocol receives the accuracy parameter $1^{\eps}$ as input to specify the allowed error, we do not need to introduce an additional soundness error parameter in the definition.


\KM{should be better to add more discussion.}

%\KM{point to discuss: (i) syntax: accuracy parameter $\eps$ (ii) simulation-based soundness (iii) no soundness error (iv) computational soundness
}


%Intuitively, completeness requires that when the prover $P$ is honest, the verifier $V$ should accept with high probability and output a sample $z$ close to $D_x$ on input $x$. Soundness should require that 


\begin{definition}
    \label{dfn:stats-secure-proto-sampbqp}
    Let $\Pi=(P, V)$ be a $\QPIP_\tau$ protocol.
    We say it is a protocol for the $\SampBQP$ instance $(D_x)_{x\in\zo^*}$ with completeness error $c(\cdot)$ and statistical (resp., computational) soundness if the following holds:
    \begin{itemize}
        \item On public inputs $1^\lambda$, $1^{1/\eps}$, and $x\in\zo^{\poly(\lambda)}$, $V$ outputs $(d, z)$ where $d\in\set{\Acc, \Rej}$.
            If $d=\Acc$ then $z\in\zo^{m(\abs{x})}$ where $m$ is given in \Cref{dfn:sampling-problem}, otherwise $z=\bot$.
        \item (Completeness):
            For all accuracy parameter $\eps(\lambda)=\frac{1}{\poly(\lambda)}$,
            security parameter $\lambda\in\bbN$,
            and $x\in\zo^{\poly(\lambda)}$,
            Let $(d, z)\leftarrow(P, V)(1^\lambda, 1^{1/\eps}, x)$, then $d=\Rej$ with probability at most $c(\lambda)$.
        \item (Statistical soundness): For all cheating prover $P^*$,
            accuracy parameter $\eps(\lambda)=\frac{1}{\poly(\lambda)}$,
            sufficiently large $\lambda\in\bbN$, and $x\in\zo^{\poly(\lambda)}$,
            consider the following experiment:
            \begin{itemize}
                \item Let $(d, z)\leftarrow(P^*, V)(1^\lambda, 1^{1/\eps}, x)$.
                \item Define $z_{ideal}$ by
                $$\begin{cases}
                    z_{ideal}=\bot & \text{if } d=\Rej\\
                    z_{ideal}\leftarrow D_x & \text{if } d=\Acc
                \end{cases}$$.
            \end{itemize}
            It holds that $\norm{(d,z)-(d,z_{ideal})}_{TV}\leq\eps$.
		\item (Computational soundness):
			\Ethan{tried to write in terms of indistinguishability}
        For all cheating $\BQP$ prover $P^*$, $\BQP$ distinguisher $\mathsf{D}$, accuracy parameter $\eps(\lambda)=\frac{1}{\poly(\lambda)}$,
            sufficiently large $\lambda\in\bbN$, and all $x\in\zo^{\poly(\lambda)}$,
            define $d, z, z_{ideal}$ by the same experiment as above.
            It holds that $(d, z)$ is $\eps$-computationally indistinguishable to $(d, z_{ideal})$ over $\lambda$.
    \end{itemize}
\end{definition}

As in the case of $\BQP$, we are particularly interested in the case that $\tau = 0$, i.e., when the verifier $V$ is classical. In this case, we say that $\Pi$ is a CVQC protocol for the $\SampBQP$ problem $(D_x)_{x\in\zo^*}$.

To the best of our knowledge, we are the first to formally define delegation of quantum sampling problems. We also note that while several constructions in the relaxed models (e.g., verifiable blind computation~\cite{FK17}) can be naturally generalized to delegate quantum sampling problem and allow the verifier to learn multi-bit outputs, it seems non-trivial to show that these constructions achieve the soundness property we defined. Proving soundness of these constructions for delegating $\SampBQP$ is an interesting open question.

\iffalse
\subsection{Sampling Problems}

We define $\SampBQP$ based on \cite{aaronson_2013, aaronson_arkhipov_2011}.
\Ethan{Tried to explain better}
This complexity class is meant to model feasible quantum computations.
As quantum states live in a continuous Hilbert space,
it is likely that any realization of quantum computing would suffer from natural noise and inaccuracies.
An argument from the physical implementation perspective that this error should be on an inverse polynomial scale is given in \cite{aaronson_arkhipov_2011}.
As a result, $\SampBQP$ is correspondingly stated to allow inverse-polynomial errors.

\begin{definition} [sampling problem]
    \label{dfn:sampling-problem}
    A \emph{sampling problem} is a collection of probability distributions $(D_x)_{x\in\set{0, 1}^*}$, one for each input string $x\in\set{0,1}^n$, where $D_x$ is a distribution over $\set{0,1}^{m(n)}$ for some fixed polynomial $m$.
\end{definition}

\begin{definition} [$\SampBQP$]
    $\SampBQP$ is the class of sampling problems $\left(D_x\right)_{x\in\set{0, 1}^*}$ that can be (approximately) sampled by polynomial-size uniform quantum circuits. Namely, there exists a Turing machine $M$ such that for every $n \in \bbN$ and $\eps \in (0,1)$, $M(1^n, 1^{1/\eps})$ outputs a quantum circuit $C$ in $\poly(n, 1/\eps)$ time such that for every $x \in \zo^n$, the output of $C(x)$ (measured in standard basis) is $\eps$-close to $D_x$.
\end{definition}




\subsection{Quantum Prover Interactive Protocols (QPIP)}

We model the interaction between a (almost classical) client and a quantum server following \cite{FOCS:Mahadev18a}.
When the client has limited quantum memories, this is a ``streaming" model.
That is, the server can send qubits one-by-one to let client measure them sequentially,
even if the client cannot hold the entire quantum message.
When the client is fully classical,
this model specializes to the standard rounds-based model.

\begin{definition}
    A protocol $\Pi=(P, V)$ is said to be in $\QPIP_\tau$ if it satisfies the following properties:
    \begin{itemize}
        \item $P$ is a $\BQP$ machine, which also has access to a quantum channel that can transmit $\tau$ qubits to the verifier per use.
        \item $V$ is a hybrid machine of a classical part and a limited quantum part. The classical part is a $\BPP$ machine. The quantum part is a register of $\tau$ qubits, on which the verifier can perform arbitrary quantum operations and which has access to a quantum channel which can transmit $\tau$ qubits. At any given time, the verifier is not allowed to possess more than $\tau$ qubits. The interaction between the quantum and classical parts of the verifier is the usual one: the classical part controls which operations are to be performed on the quantum register, and outcomes of measurements of the quantum register can be used as input to the classical part.
        \item There is also a classical communication channel between the prover and the verifier, which can transmit polynomially many bits to either direction.
    \end{itemize}
\end{definition}

It is straightforward to write down what it means for a $\QPIP_\tau$ protocol to recognize a $\BQP$ language.

\begin{definition}
    Let $\Pi=(P, V)$ be a $\QPIP_\tau$ protocol.
    We say it is a protocol for a $\BQP$ language $L$ with completeness error $c(\cdot)$ and soundness error $s(\cdot)$ if the following holds:
\begin{itemize}
        \item On public inputs $1^\lambda$ and $x\in\zo^*$, the verifier outputs either $\Acc$ or $\Rej$.
        \item (Completeness): For all security parameter $\lambda\in\bbN$ and $x\in\zo^{\poly(\lambda)}$, if $x\in L$ then
        $\Pr\left[(P, V)(x, 1^\lambda)=\Rej\right]<c(\lambda)$.
        \item (Soundness): For all cheating $\BQP$ prover $P^*$, sufficiently large security parameter $\lambda\in\bbN$, and $x\in\zo^{\poly(\lambda)}$, if $x \notin L$ then $\Pr\left[(P, V)(x, 1^\lambda)=\Rej\right]<s(\lambda)$.
    \end{itemize}
\end{definition}

It is less simple to state what it means for a $\QPIP_\tau$ protocol to solve a $\SampBQP$ instance.
We cannot hope for the protocol's output distribution to be close to the true distribution,
since a cheating prover can abort to force the verifier output $\bot$ with arbitrary probability.
On the other hand, we can ask that the output distribution to be close to the true one whenever the protocol does not abort.

\begin{definition}
    \label{dfn:stats-secure-proto-sampbqp}
    Let $\Pi=(P, V)$ be a $\QPIP_\tau$ protocol.
    We say it is a protocol for the $\SampBQP$ instance $(D_x)_{x\in\zo^*}$ with completeness error $c(\cdot)$ and statistical (resp., computational) soundness if the following holds:
    \begin{itemize}
        \item On public inputs $1^\lambda$, $1^{1/\eps}$, and $x\in\zo^{\poly(\lambda)}$, $V$ outputs $(d, z)$ where $d\in\set{\Acc, \Rej}$.
            If $d=\Acc$ then $z\in\zo^{m(\abs{x})}$ where $m$ is given in \Cref{dfn:sampling-problem}, otherwise $z=\bot$.
        \item (Completeness):
            For all accuracy parameter $\eps(\lambda)=\frac{1}{\poly(\lambda)}$,
            security parameter $\lambda\in\bbN$,
            and $x\in\zo^{\poly(\lambda)}$,
            Let $(d, z)\leftarrow(P, V)(1^\lambda, 1^{1/\eps}, x)$, then $d=\Rej$ with probability at most $c(\lambda)$.
        \item (Statistical soundness): For all cheating prover $P^*$,
            accuracy parameter $\eps(\lambda)=\frac{1}{\poly(\lambda)}$,
            sufficiently large $\lambda\in\bbN$, and $x\in\zo^{\poly(\lambda)}$,
            consider the following experiment:
            \begin{itemize}
                \item Let $(d, z)\leftarrow(P^*, V)(1^\lambda, 1^{1/\eps}, x)$.
                \item Define $z_{ideal}$ by
                $$\begin{cases}
                    z_{ideal}=\bot & \text{if } d=\Rej\\
                    z_{ideal}\leftarrow D_x & \text{if } d=\Acc
                \end{cases}$$.
            \end{itemize}
            It holds that $\norm{(d,z)-(d,z_{ideal})}_{TV}\leq\eps$.
		\item (Computational soundness):
			\Ethan{tried to write in terms of indistinguishability}
        For all cheating $\BQP$ prover $P^*$, $\BQP$ distinguisher $\mathsf{D}$, accuracy parameter $\eps(\lambda)=\frac{1}{\poly(\lambda)}$,
            sufficiently large $\lambda\in\bbN$, and all $x\in\zo^{\poly(\lambda)}$,
            define $d, z, z_{ideal}$ by the same experiment as above.
            It holds that $(d, z)$ is $\eps$-computationally indistinguishable to $(d, z_{ideal})$ over $\lambda$.
    \end{itemize}
\end{definition}

\begin{remark} Note that we do not parameterize the soundness error in Definition \ref{dfn:stats-secure-proto-sampbqp}. This is because the definition of $\SampBQP$ already includes an error parameter $\eps$, where the algorithm is allowed to generate a sample with statistical error up to $\eps$ in time polynomial in $1/\eps$. Hence, we define the soundness to  allow the verifier's output to have an $\eps$ error for any given inverse polynomial $\eps$ without introducing an extra soundness error parameter.
\end{remark}

We now define blindness of a protocol.
In the context of blind protocols, we consider $x$ as the verifier's private input instead of a common input.  

\Ethan{The following blindness definition is more crypto-based, but since we're submitting it to Eurocrypt maybe this is fine as-is?}

\begin{definition}[Blindness]
    Let $\Pi=(P, V)$ be an interactive protocol with common inputs $1^\lambda$ (and $1^{1/\eps}$ for the case of $\SampBQP$ problem), and verifier's private input $x\in\zo^*$.
    We say $\Pi$ is \emph{blind} if for all cheating $\BQP$ prover $P^*$ the following ensembles are computationally indistinguishable over $\lambda$:
    \begin{itemize}
        \item $\set{\View_{P^*}(P^*, V(x))(1^\lambda, 1^{1/\eps})}_{\lambda\in\bbN, \eps\in(0,1), x\in\zo^*}$
        \item $\set{\View_{P^*}(P^*, V(0))(1^\lambda, 1^{1/\eps})}_{\lambda\in\bbN, \eps\in(0,1), x\in\zo^*}$
    \end{itemize}
\end{definition}


\fi